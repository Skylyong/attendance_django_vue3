{"ast":null,"code":"/**axios封装\n * 请求拦截、相应拦截、错误统一处理\n */\nimport axios from 'axios';\nimport QS from 'qs';\nimport { Toast } from 'vant';\nimport store from '../store/index'; // 环境的切换\n\nif (process.env.NODE_ENV == 'development') {\n  axios.defaults.baseURL = '/api';\n} else if (process.env.NODE_ENV == 'debug') {\n  axios.defaults.baseURL = '';\n} else if (process.env.NODE_ENV == 'production') {\n  axios.defaults.baseURL = 'http://api.123dailu.com/';\n} // 请求超时时间\n\n\naxios.defaults.timeout = 10000;\naxios.defaults.xsrfCookieName = 'csrfmiddlewaretoken';\naxios.defaults.xsrfHeaderName = 'X-XSRF-TOKEN';\naxios.defaults.withCredentials = true; // post请求头\n\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\naxios.get('/login/', {\n  withCredentials: true\n}).then(response => {\n  console.log(response);\n  axios.defaults.headers['X-CSRFToken'] = getCsfrKey();\n}); // 请求拦截器\n\naxios.interceptors.request.use(config => {\n  // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了\n  // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n  const token = store.state.token;\n  token && (config.headers.Authorization = token);\n  return config;\n}, error => {\n  return Promise.error(error);\n}); // 响应拦截器\n\naxios.interceptors.response.use(response => {\n  if (response.status === 200) {\n    return Promise.resolve(response);\n  } else {\n    return Promise.reject(response);\n  }\n}, // 服务器状态码不是200的情况    \nerror => {\n  if (error.response.status) {\n    switch (error.response.status) {\n      // 401: 未登录                \n      // 未登录则跳转登录页面，并携带当前页面的路径                \n      // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n      case 401:\n        router.replace({\n          path: '/login',\n          query: {\n            redirect: router.currentRoute.fullPath\n          }\n        });\n        break;\n      // 403 token过期                \n      // 登录过期对用户进行提示                \n      // 清除本地token和清空vuex中token对象                \n      // 跳转登录页面                \n\n      case 403:\n        Toast({\n          message: '登录过期，请重新登录',\n          duration: 1000,\n          forbidClick: true\n        }); // 清除token                    \n\n        localStorage.removeItem('token');\n        store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面\n\n        setTimeout(() => {\n          router.replace({\n            path: '/login',\n            query: {\n              redirect: router.currentRoute.fullPath\n            }\n          });\n        }, 1000);\n        break;\n      // 404请求不存在                \n\n      case 404:\n        Toast({\n          message: '网络请求不存在',\n          duration: 1500,\n          forbidClick: true\n        });\n        break;\n      // 其他错误，直接抛出错误提示                \n\n      default:\n        Toast({\n          message: error.response.data.message,\n          duration: 1500,\n          forbidClick: true\n        });\n    }\n\n    return Promise.reject(error.response);\n  }\n});\n/** \n * get方法，对应get请求 \n * @param {String} url [请求的url地址] \n * @param {Object} params [请求时携带的参数] \n */\n\nexport function get(url, params) {\n  return new Promise((resolve, reject) => {\n    axios.get(url, {\n      params: params\n    }).then(res => {\n      resolve(res.data);\n    }).catch(err => {\n      reject(err.data);\n    });\n  });\n}\n/** \n * post方法，对应post请求 \n * @param {String} url [请求的url地址] \n * @param {Object} params [请求时携带的参数] \n */\n\nexport function post(url, params) {\n  return new Promise((resolve, reject) => {\n    axios.post(url, QS.stringify(params)).then(res => {\n      resolve(res.data);\n    }).catch(err => {\n      reject(err.data);\n    });\n  });\n}","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/src/api/http.js"],"names":["axios","QS","Toast","store","process","env","NODE_ENV","defaults","baseURL","timeout","xsrfCookieName","xsrfHeaderName","withCredentials","headers","post","get","then","response","console","log","getCsfrKey","interceptors","request","use","config","token","state","Authorization","error","Promise","status","resolve","reject","router","replace","path","query","redirect","currentRoute","fullPath","message","duration","forbidClick","localStorage","removeItem","commit","setTimeout","data","url","params","res","catch","err","stringify"],"mappings":"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","sourcesContent":["/**axios封装\n * 请求拦截、相应拦截、错误统一处理\n */\n import axios from 'axios';import QS from 'qs';\n import { Toast } from 'vant';\n import store from '../store/index'\n \n // 环境的切换\n \n if (process.env.NODE_ENV == 'development') {    \n     axios.defaults.baseURL = '/api';\n } else if (process.env.NODE_ENV == 'debug') {    \n     axios.defaults.baseURL = '';\n } else if (process.env.NODE_ENV == 'production') {    \n     axios.defaults.baseURL = 'http://api.123dailu.com/';\n }\n \n // 请求超时时间\n axios.defaults.timeout = 10000;\n axios.defaults.xsrfCookieName = 'csrfmiddlewaretoken'\n axios.defaults.xsrfHeaderName = 'X-XSRF-TOKEN'\n axios.defaults.withCredentials = true\n \n // post请求头\n axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n \n\n axios.get('/login/',{withCredentials: true})\n        .then((response) => {\n          console.log(response)\n          axios.defaults.headers['X-CSRFToken'] = getCsfrKey()\n        })\n\n\n\n // 请求拦截器\n axios.interceptors.request.use(    \n     config => {\n         // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了\n         // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n         const token = store.state.token;        \n         token && (config.headers.Authorization = token);        \n         return config;    \n     },    \n     error => {        \n         return Promise.error(error);    \n     })\n \n // 响应拦截器\n axios.interceptors.response.use(    \n     response => {        \n         if (response.status === 200) {            \n             return Promise.resolve(response);        \n         } else {            \n             return Promise.reject(response);        \n         }    \n     },\n     // 服务器状态码不是200的情况    \n     error => {        \n         if (error.response.status) {            \n             switch (error.response.status) {                \n                 // 401: 未登录                \n                 // 未登录则跳转登录页面，并携带当前页面的路径                \n                 // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n                 case 401:                    \n                     router.replace({                        \n                         path: '/login',                        \n                         query: { redirect: router.currentRoute.fullPath } \n                     });\n                     break;\n                 // 403 token过期                \n                 // 登录过期对用户进行提示                \n                 // 清除本地token和清空vuex中token对象                \n                 // 跳转登录页面                \n                 case 403:                     \n                     Toast({                        \n                         message: '登录过期，请重新登录',                        \n                         duration: 1000,                        \n                         forbidClick: true                    \n                     });                    \n                     // 清除token                    \n                     localStorage.removeItem('token');                    \n                     store.commit('loginSuccess', null);                    \n                     // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面\n                     setTimeout(() => {                        \n                         router.replace({                            \n                             path: '/login',                            \n                             query: { \n                                 redirect: router.currentRoute.fullPath \n                             }                        \n                         });                    \n                     }, 1000);                    \n                     break; \n                 // 404请求不存在                \n                 case 404:                    \n                     Toast({                        \n                         message: '网络请求不存在',                        \n                         duration: 1500,                        \n                         forbidClick: true                    \n                     });                    \n                 break;                \n                 // 其他错误，直接抛出错误提示                \n                 default:                    \n                     Toast({                        \n                         message: error.response.data.message,                        \n                         duration: 1500,                        \n                         forbidClick: true                    \n                     });            \n             }            \n             return Promise.reject(error.response);        \n         }       \n     }\n );\n /** \n  * get方法，对应get请求 \n  * @param {String} url [请求的url地址] \n  * @param {Object} params [请求时携带的参数] \n  */\n export function get(url, params){    \n     return new Promise((resolve, reject) =>{        \n         axios.get(url, {            \n             params: params        \n         })        \n         .then(res => {            \n             resolve(res.data);        \n         })        \n         .catch(err => {            \n             reject(err.data)        \n         })    \n     });\n }\n /** \n  * post方法，对应post请求 \n  * @param {String} url [请求的url地址] \n  * @param {Object} params [请求时携带的参数] \n  */\n export function post(url, params) {    \n     return new Promise((resolve, reject) => {         \n         axios.post(url, QS.stringify(params))        \n         .then(res => {            \n             resolve(res.data);        \n         })        \n         .catch(err => {            \n             reject(err.data)        \n         })    \n     });\n }\n "]},"metadata":{},"sourceType":"module"}