{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { defineComponent, provide, unref, ref, computed, inject, reactive, watch, onUnmounted, watchEffect } from 'vue';\nconst GLOBAL_OPTIONS = {};\nconst GLOBAL_OPTIONS_PROVIDE_KEY = Symbol('GLOBAL_OPTIONS_PROVIDE_KEY');\n\nconst setGlobalOptions = config => {\n  Object.keys(config).forEach(key => {\n    GLOBAL_OPTIONS[key] = config[key];\n  });\n};\n\nconst getGlobalOptions = () => {\n  return GLOBAL_OPTIONS;\n};\n\nconst RequestConfig = defineComponent({\n  name: 'RequestConfig',\n  props: {\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const {\n      config\n    } = props;\n    provide(GLOBAL_OPTIONS_PROVIDE_KEY, config);\n    return () => {\n      var _slots$default;\n\n      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);\n    };\n  }\n\n});\nconst objectToString = Object.prototype.toString;\n\nconst toTypeString = val => objectToString.call(val);\n\nconst isString = val => toTypeString(val) === '[object String]';\n\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\n\nconst isArray = val => Array.isArray(val);\n\nconst isObject = val => val !== null && typeof val === 'object';\n\nconst isPromise = fn => isObject(fn) && isFunction(fn.then) && isFunction(fn.catch);\n\nconst isFunction = fn => fn instanceof Function;\n\nconst isNil = val => val === null || val === undefined;\n\nconst isServer = typeof window === 'undefined';\n\nconst isDocumentVisibility = () => {\n  var _window, _window$document;\n\n  return !isServer && ((_window = window) === null || _window === void 0 ? void 0 : (_window$document = _window.document) === null || _window$document === void 0 ? void 0 : _window$document.visibilityState) === 'visible';\n};\n\nconst isOnline = () => {\n  var _ref, _window2, _window2$navigator;\n\n  return (_ref = !isServer && ((_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$navigator = _window2.navigator) === null || _window2$navigator === void 0 ? void 0 : _window2$navigator.onLine)) !== null && _ref !== void 0 ? _ref : true;\n};\n\nconst unRefObject = val => {\n  const obj = {};\n  Object.keys(val).forEach(key => {\n    obj[key] = unref(val[key]);\n  });\n  return obj;\n};\n\nconst resolvedPromise = Promise.resolve(null);\n\nconst requestProxy = async (...args) => {\n  const res = await fetch(...args);\n\n  if (res.ok) {\n    return res.json();\n  }\n\n  throw new Error(res.statusText);\n};\n\nconst get = (source, path, defaultValue = undefined) => {\n  // a[3].b -> a.3.b\n  const paths = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.');\n  let result = source;\n\n  for (const p of paths) {\n    result = Object(result)[p];\n\n    if (result === undefined) {\n      return defaultValue;\n    }\n  }\n\n  return result;\n};\n\nfunction omit(object, keys) {\n  const result = Object.assign({}, object);\n\n  for (const key of keys) {\n    delete result[key];\n  }\n\n  return result;\n}\n\nconst warning = (message, throwError = false) => {\n  const msg = `Warning: [vue-request] ${message}`;\n\n  if (throwError) {\n    return new Error(msg);\n  } else {\n    console.error(msg);\n  }\n};\n\nconst limitTrigger = (fn, timeInterval) => {\n  let running = false;\n  return (...args) => {\n    if (running) return;\n    running = true;\n    fn(...args);\n    setTimeout(() => {\n      running = false;\n    }, timeInterval);\n  };\n};\n\nvar _window;\n\nconst FOCUS_LISTENER = new Set();\nconst VISIBLE_LISTENER = new Set();\nconst RECONNECT_LISTENER = new Set();\n\nconst subscriber = (listenerType, event) => {\n  let listeners;\n\n  switch (listenerType) {\n    case 'FOCUS_LISTENER':\n      listeners = FOCUS_LISTENER;\n      break;\n\n    case 'RECONNECT_LISTENER':\n      listeners = RECONNECT_LISTENER;\n      break;\n\n    case 'VISIBLE_LISTENER':\n      listeners = VISIBLE_LISTENER;\n      break;\n  }\n\n  if (listeners.has(event)) return;\n  listeners.add(event);\n  return () => {\n    listeners.delete(event);\n  };\n};\n\nconst observer = listeners => {\n  listeners.forEach(event => {\n    event();\n  });\n};\n/* istanbul ignore else */\n\n\nif (!isServer && (_window = window) !== null && _window !== void 0 && _window.addEventListener) {\n  window.addEventListener('visibilitychange', () => {\n    /* istanbul ignore else */\n    if (isDocumentVisibility()) {\n      observer(VISIBLE_LISTENER);\n    }\n  }, false);\n  window.addEventListener('focus', () => observer(FOCUS_LISTENER), false);\n  window.addEventListener('online', () => observer(RECONNECT_LISTENER), false);\n}\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\n\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n\n  const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      window.cancelAnimationFrame(timerId);\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nfunction baseMerge(origin, target) {\n  for (const key in target) {\n    if (target[key] === undefined) {\n      continue;\n    }\n\n    if (!isObject(target[key]) || // `target[key]` is not an object\n    !isObject(origin[key]) || // `target[key]` is not an object\n    !(key in origin) // `key` is not in the origin object\n    ) {\n      origin[key] = target[key];\n      continue;\n    }\n\n    if (isPlainObject(target[key]) || isArray(target[key])) {\n      baseMerge(origin[key], target[key]);\n    }\n  }\n}\n\nfunction merge(origin, ...others) {\n  const result = Object.assign({}, origin);\n  if (!others.length) return result;\n\n  for (const item of others) {\n    baseMerge(result, item);\n  }\n\n  return result;\n}\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\n\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait\n  });\n}\n\nconst setStateBind = (oldState, publicCb) => {\n  return newState => {\n    Object.keys(newState).forEach(key => {\n      oldState[key].value = newState[key];\n    });\n    publicCb.forEach(fun => fun(oldState));\n  };\n};\n\nconst createQuery = (query, config, initialState) => {\n  var _initialState$loading, _initialState$data, _initialState$params;\n\n  const {\n    initialAutoRunFlag,\n    initialData,\n    loadingDelay,\n    pollingInterval,\n    debounceInterval,\n    debounceOptions,\n    throttleInterval,\n    throttleOptions,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    errorRetryCount,\n    errorRetryInterval,\n    stopPollingWhenHiddenOrOffline,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    formatResult,\n    onSuccess,\n    onError,\n    onBefore,\n    onAfter\n  } = config;\n  const retriedCount = ref(0);\n  const loading = ref((_initialState$loading = initialState === null || initialState === void 0 ? void 0 : initialState.loading) !== null && _initialState$loading !== void 0 ? _initialState$loading : false);\n  const data = ref((_initialState$data = initialState === null || initialState === void 0 ? void 0 : initialState.data) !== null && _initialState$data !== void 0 ? _initialState$data : initialData);\n  const error = ref(initialState === null || initialState === void 0 ? void 0 : initialState.error);\n  const params = ref((_initialState$params = initialState === null || initialState === void 0 ? void 0 : initialState.params) !== null && _initialState$params !== void 0 ? _initialState$params : []);\n  const setState = setStateBind({\n    loading,\n    data,\n    error,\n    params\n  }, [state => updateCache(state)]); // reset retried count\n\n  const resetRetriedCount = () => {\n    retriedCount.value = 0;\n  };\n\n  const count = ref(0);\n  const pollingTimer = ref();\n  const retryTimer = ref();\n  const delayLoadingTimer = ref();\n\n  const clearAllTimer = () => {\n    // clear pollingTimer\n    if (pollingTimer.value) {\n      pollingTimer.value();\n    } // clear delayLoadingTimer\n\n\n    if (delayLoadingTimer.value) {\n      delayLoadingTimer.value();\n    } // clear retryTimer\n\n\n    if (retryTimer.value) {\n      retryTimer.value();\n    }\n  };\n\n  const delayLoading = () => {\n    let timerId;\n\n    if (loadingDelay) {\n      timerId = setTimeout(setState, loadingDelay, {\n        loading: true\n      });\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const polling = pollingFunc => {\n    // if errorRetry is enabled, then skip this method\n    if (error.value && errorRetryCount !== 0) return;\n    let timerId;\n\n    if (!isNil(pollingInterval) && pollingInterval >= 0) {\n      if ((pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n        timerId = setTimeout(pollingFunc, pollingInterval);\n      } else {\n        // stop polling\n        stopPollingWhenHiddenOrOffline.value = true;\n        return;\n      }\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const actualErrorRetryInterval = computed(() => {\n    if (errorRetryInterval) return errorRetryInterval;\n    const baseTime = 1000;\n    const minCoefficient = 1;\n    const maxCoefficient = 9; // When retrying for the first time, in order to avoid the coefficient being 0\n    // so replace 0 with 2, the coefficient range will become 1 - 2\n\n    const coefficient = Math.floor(Math.random() * 2 ** Math.min(retriedCount.value, maxCoefficient) + minCoefficient);\n    return baseTime * coefficient;\n  });\n\n  const errorRetryHooks = retryFunc => {\n    let timerId;\n    const isInfiniteRetry = errorRetryCount === -1;\n    const hasRetryCount = retriedCount.value < errorRetryCount; // if errorRetryCount is -1, it will retry the request until it success\n\n    if (error.value && (isInfiniteRetry || hasRetryCount)) {\n      if (!isInfiniteRetry) retriedCount.value += 1;\n      timerId = setTimeout(retryFunc, actualErrorRetryInterval.value);\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const _run = (...args) => {\n    setState({\n      loading: !loadingDelay,\n      params: args\n    });\n    delayLoadingTimer.value = delayLoading();\n    count.value += 1;\n    const currentCount = count.value; // onBefore hooks\n\n    onBefore === null || onBefore === void 0 ? void 0 : onBefore(args);\n    return query(...args).then(res => {\n      if (currentCount === count.value) {\n        const formattedResult = formatResult ? formatResult(res) : res;\n        setState({\n          data: formattedResult,\n          loading: false,\n          error: undefined\n        });\n\n        if (onSuccess) {\n          onSuccess(formattedResult, args);\n        }\n\n        resetRetriedCount();\n        return formattedResult;\n      }\n\n      return resolvedPromise;\n    }).catch(error => {\n      if (currentCount === count.value) {\n        setState({\n          data: undefined,\n          loading: false,\n          error: error\n        });\n\n        if (onError) {\n          onError(error, args);\n        }\n\n        console.error(error);\n      }\n\n      return resolvedPromise;\n    }).finally(() => {\n      if (currentCount === count.value) {\n        // clear delayLoadingTimer\n        delayLoadingTimer.value(); // retry\n\n        retryTimer.value = errorRetryHooks(() => _run(...args)); // run for polling\n\n        pollingTimer.value = polling(() => _run(...args)); // onAfter hooks\n\n        onAfter === null || onAfter === void 0 ? void 0 : onAfter(args);\n      }\n    });\n  };\n\n  const debouncedRun = !isNil(debounceInterval) && debounce(_run, debounceInterval, debounceOptions);\n  const throttledRun = !isNil(throttleInterval) && throttle(_run, throttleInterval, throttleOptions);\n\n  const run = (...args) => {\n    clearAllTimer(); // initial auto run should not debounce\n\n    if (!initialAutoRunFlag.value && debouncedRun) {\n      debouncedRun(...args);\n      return resolvedPromise;\n    }\n\n    if (throttledRun) {\n      throttledRun(...args);\n      return resolvedPromise;\n    }\n\n    resetRetriedCount();\n    return _run(...args);\n  };\n\n  const cancel = () => {\n    count.value += 1;\n    setState({\n      loading: false\n    });\n\n    if (debouncedRun) {\n      debouncedRun.cancel();\n    }\n\n    if (throttledRun) {\n      throttledRun.cancel();\n    }\n\n    clearAllTimer();\n  };\n\n  const refresh = () => {\n    return run(...params.value);\n  };\n\n  const mutate = x => {\n    const mutateData = isFunction(x) ? x(data.value) : x;\n    setState({\n      data: mutateData\n    });\n  }; // collect subscribers, in order to unsubscribe when the component unmounted\n\n\n  const unsubscribeList = [];\n\n  const addUnsubscribeList = event => {\n    event && unsubscribeList.push(event);\n  };\n\n  const rePolling = () => {\n    if (stopPollingWhenHiddenOrOffline.value && (pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n      refresh();\n      stopPollingWhenHiddenOrOffline.value = false;\n    }\n  }; // subscribe polling\n\n\n  if (!pollingWhenHidden) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', rePolling));\n  } // subscribe online when pollingWhenOffline is false\n\n\n  if (!pollingWhenOffline) {\n    addUnsubscribeList(subscriber('RECONNECT_LISTENER', rePolling));\n  }\n\n  const limitRefresh = limitTrigger(refresh, refocusTimespan); // subscribe window focus or visible\n\n  if (refreshOnWindowFocus) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', limitRefresh));\n    addUnsubscribeList(subscriber('FOCUS_LISTENER', limitRefresh));\n  }\n\n  const unmount = () => {\n    unsubscribeList.forEach(unsubscribe => unsubscribe());\n  };\n\n  return {\n    loading,\n    data,\n    error,\n    params,\n    run,\n    cancel,\n    refresh,\n    mutate,\n    unmount\n  };\n};\n\nconst CACHE_MAP = new Map();\n\nconst getCache = cacheKey => {\n  if (isNil(cacheKey)) return;\n  const data = CACHE_MAP.get(cacheKey);\n  if (!data) return;\n  return {\n    data: data.data,\n    cacheTime: data.cacheTime\n  };\n};\n\nconst setCache = (cacheKey, data, cacheTime) => {\n  const oldCache = CACHE_MAP.get(cacheKey);\n\n  if (oldCache !== null && oldCache !== void 0 && oldCache.timer) {\n    clearTimeout(oldCache.timer);\n  }\n\n  const timer = setTimeout(() => CACHE_MAP.delete(cacheKey), cacheTime);\n  CACHE_MAP.set(cacheKey, {\n    data,\n    timer,\n    cacheTime: new Date().getTime()\n  });\n};\n\nconst QUERY_DEFAULT_KEY = '__QUERY_DEFAULT_KEY__';\n\nfunction useAsyncQuery(query, options) {\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    cacheKey,\n    defaultParams = [],\n    manual = false,\n    ready = ref(true),\n    refreshDeps = [],\n    loadingDelay = 0,\n    pollingWhenHidden = false,\n    pollingWhenOffline = false,\n    refreshOnWindowFocus = false,\n    refocusTimespan = 5000,\n    cacheTime = 600000,\n    staleTime = 0,\n    errorRetryCount = 0,\n    errorRetryInterval = 0,\n    queryKey,\n    ...rest\n  } = { ...getGlobalOptions(),\n    ...injectedGlobalOptions,\n    ...options\n  };\n  const stopPollingWhenHiddenOrOffline = ref(false); // skip debounce when initail run\n\n  const initialAutoRunFlag = ref(false);\n\n  const updateCache = state => {\n    var _getCache, _queryKey;\n\n    if (!cacheKey) return;\n    const cacheData = (_getCache = getCache(cacheKey)) === null || _getCache === void 0 ? void 0 : _getCache.data;\n    const cacheQueries = cacheData === null || cacheData === void 0 ? void 0 : cacheData.queries;\n    const queryData = unRefObject(state);\n    const currentQueryKey = (_queryKey = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...state.params.value)) !== null && _queryKey !== void 0 ? _queryKey : QUERY_DEFAULT_KEY;\n    setCache(cacheKey, {\n      queries: { ...cacheQueries,\n        [currentQueryKey]: { ...(cacheQueries === null || cacheQueries === void 0 ? void 0 : cacheQueries[currentQueryKey]),\n          ...queryData\n        }\n      },\n      latestQueriesKey: currentQueryKey\n    }, cacheTime);\n  };\n\n  const config = {\n    initialAutoRunFlag,\n    loadingDelay,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    stopPollingWhenHiddenOrOffline,\n    cacheKey,\n    errorRetryCount,\n    errorRetryInterval,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    ...omit(rest, ['pagination', 'listKey'])\n  };\n  const loading = ref(false);\n  const data = ref();\n  const error = ref();\n  const params = ref();\n  const queries = reactive({\n    [QUERY_DEFAULT_KEY]: reactive(createQuery(query, config))\n  });\n  const latestQueriesKey = ref(QUERY_DEFAULT_KEY);\n  const latestQuery = computed(() => {\n    var _queries$latestQuerie;\n\n    return (_queries$latestQuerie = queries[latestQueriesKey.value]) !== null && _queries$latestQuerie !== void 0 ? _queries$latestQuerie : {};\n  }); // sync state\n\n  watch(latestQuery, queryData => {\n    loading.value = queryData.loading;\n    data.value = queryData.data;\n    error.value = queryData.error;\n    params.value = queryData.params;\n  }, {\n    immediate: true,\n    deep: true\n  }); // init queries from cache\n\n  if (cacheKey) {\n    var _cache$data;\n\n    const cache = getCache(cacheKey);\n\n    if (cache !== null && cache !== void 0 && (_cache$data = cache.data) !== null && _cache$data !== void 0 && _cache$data.queries) {\n      Object.keys(cache.data.queries).forEach(key => {\n        const cacheQuery = cache.data.queries[key];\n        queries[key] = reactive(createQuery(query, config, {\n          loading: cacheQuery.loading,\n          params: cacheQuery.params,\n          data: cacheQuery.data,\n          error: cacheQuery.error\n        }));\n      });\n      /* istanbul ignore else */\n\n      if (cache.data.latestQueriesKey) {\n        latestQueriesKey.value = cache.data.latestQueriesKey;\n      }\n    }\n  }\n\n  const tempReadyParams = ref();\n  const hasTriggerReady = ref(false);\n\n  const run = (...args) => {\n    var _queryKey2;\n\n    if (!ready.value && !hasTriggerReady.value) {\n      tempReadyParams.value = args;\n      return resolvedPromise;\n    }\n\n    const newKey = (_queryKey2 = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...args)) !== null && _queryKey2 !== void 0 ? _queryKey2 : QUERY_DEFAULT_KEY;\n\n    if (!queries[newKey]) {\n      queries[newKey] = reactive(createQuery(query, config));\n    }\n\n    latestQueriesKey.value = newKey;\n    return latestQuery.value.run(...args);\n  };\n\n  const reset = () => {\n    unmountQueries();\n    latestQueriesKey.value = QUERY_DEFAULT_KEY;\n    queries[QUERY_DEFAULT_KEY] = reactive(createQuery(query, config));\n  }; // unmount queries\n\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      queries[key].cancel();\n      queries[key].unmount();\n      delete queries[key];\n    });\n  };\n\n  const cancel = () => latestQuery.value.cancel();\n\n  const refresh = () => latestQuery.value.refresh();\n\n  const mutate = arg => latestQuery.value.mutate(arg); // initial run\n\n\n  if (!manual) {\n    var _cache$data$queries;\n\n    initialAutoRunFlag.value = true; // TODO: need refactor\n\n    const cache = getCache(cacheKey);\n    const cacheQueries = (_cache$data$queries = cache === null || cache === void 0 ? void 0 : cache.data.queries) !== null && _cache$data$queries !== void 0 ? _cache$data$queries : {};\n    const isFresh = cache && (staleTime === -1 || cache.cacheTime + staleTime > new Date().getTime());\n    const hasCacheQueries = Object.keys(cacheQueries).length > 0;\n\n    if (!isFresh) {\n      if (hasCacheQueries) {\n        Object.keys(queries).forEach(key => {\n          var _queries$key;\n\n          (_queries$key = queries[key]) === null || _queries$key === void 0 ? void 0 : _queries$key.refresh();\n        });\n      } else {\n        run(...defaultParams);\n      }\n    }\n\n    initialAutoRunFlag.value = false;\n  } // watch ready\n\n\n  const stopReady = ref();\n  stopReady.value = watch(ready, val => {\n    hasTriggerReady.value = true;\n\n    if (val && tempReadyParams.value) {\n      run(...tempReadyParams.value); // destroy current watch\n\n      stopReady.value();\n    }\n  }, {\n    flush: 'sync'\n  }); // watch refreshDeps\n\n  if (refreshDeps.length) {\n    watch(refreshDeps, () => {\n      !manual && latestQuery.value.refresh();\n    });\n  }\n\n  onUnmounted(() => {\n    unmountQueries();\n  });\n  return {\n    loading,\n    data,\n    error,\n    params,\n    cancel,\n    refresh,\n    mutate,\n    run,\n    reset,\n    queries\n  };\n}\n\nconst generateService = service => {\n  return (...args) => {\n    if (isFunction(service)) {\n      return generateService(service(...args))();\n    } else if (isPromise(service)) {\n      return service;\n    } else if (isPlainObject(service)) {\n      const {\n        url,\n        ...rest\n      } = service;\n      return requestProxy(url, rest);\n    } else if (isString(service)) {\n      return requestProxy(service);\n    } else {\n      throw warning('Unknown service type', true);\n    }\n  };\n};\n\nfunction useLoadMore(service, options) {\n  var _injectedGlobalOption;\n\n  if (!isFunction(service)) {\n    warning('useLoadMore only support function service');\n  }\n\n  const promiseQuery = generateService(service);\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    queryKey,\n    isNoMore,\n    listKey = 'list',\n    ...restOptions\n  } = Object.assign({\n    listKey: (_injectedGlobalOption = injectedGlobalOptions.listKey) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : getGlobalOptions().listKey\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('useLoadMore does not support concurrent request');\n  }\n\n  const refreshing = ref(false);\n  const loadingMore = ref(false);\n  const reloading = ref(false);\n  const initailIncreaseQueryKey = 0;\n  const increaseQueryKey = ref(initailIncreaseQueryKey);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    cancel: _cancel,\n    ...rest\n  } = useAsyncQuery(promiseQuery, { ...restOptions,\n    onSuccess: (...p) => {\n      var _restOptions$onSucces;\n\n      loadingMore.value = false;\n      increaseQueryKey.value++;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onSucces = restOptions.onSuccess) === null || _restOptions$onSucces === void 0 ? void 0 : _restOptions$onSucces.call(restOptions, ...p);\n    },\n    onError: (...p) => {\n      var _restOptions$onError;\n\n      loadingMore.value = false;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onError = restOptions.onError) === null || _restOptions$onError === void 0 ? void 0 : _restOptions$onError.call(restOptions, ...p);\n    },\n    queryKey: () => String(increaseQueryKey.value)\n  });\n  const latestData = ref(data.value);\n  watchEffect(() => {\n    if (data.value !== undefined) {\n      latestData.value = data.value;\n    }\n  });\n  const noMore = computed(() => {\n    return isNoMore && isFunction(isNoMore) ? isNoMore(latestData.value) : false;\n  });\n  const dataList = computed(() => {\n    let list = [];\n    Object.values(queries).forEach(h => {\n      const dataList = get(h.data, listKey);\n\n      if (dataList && Array.isArray(dataList)) {\n        list = list.concat(dataList);\n      }\n    });\n    return list;\n  });\n\n  const loadMore = () => {\n    if (noMore.value) {\n      return;\n    }\n\n    loadingMore.value = true;\n    const [, ...restParams] = params.value;\n    const mergerParams = [{\n      dataList: dataList.value,\n      data: latestData.value\n    }, ...restParams];\n    run(...mergerParams);\n  };\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      if (key !== initailIncreaseQueryKey.toString()) {\n        queries[key].cancel();\n        queries[key].unmount();\n        delete queries[key];\n      }\n    });\n  };\n\n  const refresh = async () => {\n    refreshing.value = true;\n    const latestKey = increaseQueryKey.value - 1;\n    const key = latestKey < initailIncreaseQueryKey ? initailIncreaseQueryKey : latestKey;\n    latestData.value = queries[key].data;\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    unmountQueries();\n    refreshing.value = false;\n  };\n\n  const reload = async () => {\n    reloading.value = true;\n    reset();\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    latestData.value = undefined;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    reloading.value = false;\n  };\n\n  const cancel = () => {\n    _cancel();\n\n    loadingMore.value = false;\n    refreshing.value = false;\n  };\n\n  return {\n    data: latestData,\n    dataList: dataList,\n    params,\n    noMore,\n    loadingMore,\n    refreshing,\n    reloading,\n    run,\n    reload,\n    loadMore,\n    reset,\n    refresh,\n    cancel,\n    ...omit(rest, ['refresh', 'mutate'])\n  };\n}\n\nfunction usePagination(service, options) {\n  var _getGlobalOptions$pag, _injectedGlobalOption;\n\n  const promiseQuery = generateService(service);\n  const defaultOptions = {\n    pagination: {\n      currentKey: 'current',\n      pageSizeKey: 'pageSize',\n      totalKey: 'total',\n      totalPageKey: 'totalPage'\n    }\n  };\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    pagination: {\n      currentKey,\n      pageSizeKey,\n      totalKey,\n      totalPageKey\n    },\n    queryKey,\n    ...restOptions\n  } = merge(defaultOptions, {\n    pagination: (_getGlobalOptions$pag = getGlobalOptions().pagination) !== null && _getGlobalOptions$pag !== void 0 ? _getGlobalOptions$pag : {}\n  }, {\n    pagination: (_injectedGlobalOption = injectedGlobalOptions.pagination) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : {}\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('usePagination does not support concurrent request');\n  }\n\n  const finallyOptions = merge({\n    defaultParams: [{\n      [currentKey]: 1,\n      [pageSizeKey]: 10\n    }]\n  }, restOptions);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    ...rest\n  } = useAsyncQuery(promiseQuery, finallyOptions);\n\n  const paging = paginationParams => {\n    const [oldPaginationParams, ...restParams] = params.value;\n    const newPaginationParams = { ...oldPaginationParams,\n      ...paginationParams\n    };\n    const mergerParams = [newPaginationParams, ...restParams];\n    run(...mergerParams);\n  }; // changeCurrent\tchange current page\t(current: number) => void\n\n\n  const changeCurrent = current => {\n    paging({\n      [currentKey]: current\n    });\n  }; // changePageSize\tchange pageSize\t(pageSize: number) => void\n\n\n  const changePageSize = pageSize => {\n    paging({\n      [pageSizeKey]: pageSize\n    });\n  }; // changePagination\tchange current and pageSize\t(current: number, pageSize: number) => void\n\n\n  const changePagination = (current, pageSize) => {\n    paging({\n      [currentKey]: current,\n      [pageSizeKey]: pageSize\n    });\n  };\n\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams,\n      manual\n    } = finallyOptions;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  const total = computed(() => get(data.value, totalKey, 0));\n  const current = computed({\n    get: () => {\n      var _params$value$0$curre, _params$value$;\n\n      return (_params$value$0$curre = (_params$value$ = params.value[0]) === null || _params$value$ === void 0 ? void 0 : _params$value$[currentKey]) !== null && _params$value$0$curre !== void 0 ? _params$value$0$curre : finallyOptions.defaultParams[0][currentKey];\n    },\n    set: val => {\n      changeCurrent(val);\n    }\n  });\n  const pageSize = computed({\n    get: () => {\n      var _params$value$0$pageS, _params$value$2;\n\n      return (_params$value$0$pageS = (_params$value$2 = params.value[0]) === null || _params$value$2 === void 0 ? void 0 : _params$value$2[pageSizeKey]) !== null && _params$value$0$pageS !== void 0 ? _params$value$0$pageS : finallyOptions.defaultParams[0][pageSizeKey];\n    },\n    set: val => {\n      changePageSize(val);\n    }\n  });\n  const totalPage = computed(() => get(data.value, totalPageKey, Math.ceil(total.value / pageSize.value)));\n  return {\n    data,\n    params,\n    current,\n    pageSize,\n    total,\n    totalPage,\n    reloading,\n    run,\n    changeCurrent,\n    changePageSize,\n    changePagination,\n    reload,\n    ...rest\n  };\n}\n\nfunction useRequest(service, options) {\n  const promiseQuery = generateService(service);\n  const {\n    reset,\n    run,\n    ...rest\n  } = useAsyncQuery(promiseQuery, options !== null && options !== void 0 ? options : {});\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams = [],\n      manual\n    } = options;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  return {\n    reload,\n    run,\n    reloading,\n    ...rest\n  };\n}\n\nexport { RequestConfig, setGlobalOptions, useLoadMore, usePagination, useRequest };","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/node_modules/vue-request/dist/index.es.js"],"names":["defineComponent","provide","unref","ref","computed","inject","reactive","watch","onUnmounted","watchEffect","GLOBAL_OPTIONS","GLOBAL_OPTIONS_PROVIDE_KEY","Symbol","setGlobalOptions","config","Object","keys","forEach","key","getGlobalOptions","RequestConfig","name","props","type","required","setup","slots","_slots$default","default","call","objectToString","prototype","toString","toTypeString","val","isString","isPlainObject","isArray","Array","isObject","isPromise","fn","isFunction","then","catch","Function","isNil","undefined","isServer","window","isDocumentVisibility","_window","_window$document","document","visibilityState","isOnline","_ref","_window2","_window2$navigator","navigator","onLine","unRefObject","obj","resolvedPromise","Promise","resolve","requestProxy","args","res","fetch","ok","json","Error","statusText","get","source","path","defaultValue","paths","replace","split","result","p","omit","object","assign","warning","message","throwError","msg","console","error","limitTrigger","timeInterval","running","setTimeout","FOCUS_LISTENER","Set","VISIBLE_LISTENER","RECONNECT_LISTENER","subscriber","listenerType","event","listeners","has","add","delete","observer","addEventListener","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","Math","max","invokeFunc","time","thisArg","apply","startTimer","pendingFunc","cancelAnimationFrame","cancelTimer","id","clearTimeout","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","min","shouldInvoke","Date","now","trailingEdge","cancel","flush","pending","debounced","isInvoking","baseMerge","origin","target","merge","others","length","item","throttle","setStateBind","oldState","publicCb","newState","value","fun","createQuery","query","initialState","_initialState$loading","_initialState$data","_initialState$params","initialAutoRunFlag","initialData","loadingDelay","pollingInterval","debounceInterval","debounceOptions","throttleInterval","throttleOptions","pollingWhenHidden","pollingWhenOffline","errorRetryCount","errorRetryInterval","stopPollingWhenHiddenOrOffline","refreshOnWindowFocus","refocusTimespan","updateCache","formatResult","onSuccess","onError","onBefore","onAfter","retriedCount","loading","data","params","setState","state","resetRetriedCount","count","pollingTimer","retryTimer","delayLoadingTimer","clearAllTimer","delayLoading","polling","pollingFunc","actualErrorRetryInterval","baseTime","minCoefficient","maxCoefficient","coefficient","floor","random","errorRetryHooks","retryFunc","isInfiniteRetry","hasRetryCount","_run","currentCount","formattedResult","finally","debouncedRun","throttledRun","run","refresh","mutate","x","mutateData","unsubscribeList","addUnsubscribeList","push","rePolling","limitRefresh","unmount","unsubscribe","CACHE_MAP","Map","getCache","cacheKey","cacheTime","setCache","oldCache","timer","set","getTime","QUERY_DEFAULT_KEY","useAsyncQuery","injectedGlobalOptions","defaultParams","manual","ready","refreshDeps","staleTime","queryKey","rest","_getCache","_queryKey","cacheData","cacheQueries","queries","queryData","currentQueryKey","latestQueriesKey","latestQuery","_queries$latestQuerie","immediate","deep","_cache$data","cache","cacheQuery","tempReadyParams","hasTriggerReady","_queryKey2","newKey","reset","unmountQueries","arg","_cache$data$queries","isFresh","hasCacheQueries","_queries$key","stopReady","generateService","service","url","useLoadMore","_injectedGlobalOption","promiseQuery","isNoMore","listKey","restOptions","refreshing","loadingMore","reloading","initailIncreaseQueryKey","increaseQueryKey","_cancel","_restOptions$onSucces","_restOptions$onError","String","latestData","noMore","dataList","list","values","h","concat","loadMore","restParams","mergerParams","latestKey","reload","usePagination","_getGlobalOptions$pag","defaultOptions","pagination","currentKey","pageSizeKey","totalKey","totalPageKey","finallyOptions","paging","paginationParams","oldPaginationParams","newPaginationParams","changeCurrent","current","changePageSize","pageSize","changePagination","total","_params$value$0$curre","_params$value$","_params$value$0$pageS","_params$value$2","totalPage","ceil","useRequest"],"mappings":"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","sourcesContent":["import { defineComponent, provide, unref, ref, computed, inject, reactive, watch, onUnmounted, watchEffect } from 'vue';\n\nconst GLOBAL_OPTIONS = {};\nconst GLOBAL_OPTIONS_PROVIDE_KEY = Symbol('GLOBAL_OPTIONS_PROVIDE_KEY');\nconst setGlobalOptions = config => {\n  Object.keys(config).forEach(key => {\n    GLOBAL_OPTIONS[key] = config[key];\n  });\n};\nconst getGlobalOptions = () => {\n  return GLOBAL_OPTIONS;\n};\n\nconst RequestConfig = defineComponent({\n  name: 'RequestConfig',\n  props: {\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const {\n      config\n    } = props;\n    provide(GLOBAL_OPTIONS_PROVIDE_KEY, config);\n    return () => {\n      var _slots$default;\n\n      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);\n    };\n  }\n\n});\n\nconst objectToString = Object.prototype.toString;\nconst toTypeString = val => objectToString.call(val);\nconst isString = val => toTypeString(val) === '[object String]';\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\nconst isArray = val => Array.isArray(val);\nconst isObject = val => val !== null && typeof val === 'object';\nconst isPromise = fn => isObject(fn) && isFunction(fn.then) && isFunction(fn.catch);\nconst isFunction = fn => fn instanceof Function;\nconst isNil = val => val === null || val === undefined;\nconst isServer = typeof window === 'undefined';\nconst isDocumentVisibility = () => {\n  var _window, _window$document;\n\n  return !isServer && ((_window = window) === null || _window === void 0 ? void 0 : (_window$document = _window.document) === null || _window$document === void 0 ? void 0 : _window$document.visibilityState) === 'visible';\n};\nconst isOnline = () => {\n  var _ref, _window2, _window2$navigator;\n\n  return (_ref = !isServer && ((_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$navigator = _window2.navigator) === null || _window2$navigator === void 0 ? void 0 : _window2$navigator.onLine)) !== null && _ref !== void 0 ? _ref : true;\n};\nconst unRefObject = val => {\n  const obj = {};\n  Object.keys(val).forEach(key => {\n    obj[key] = unref(val[key]);\n  });\n  return obj;\n};\nconst resolvedPromise = Promise.resolve(null);\nconst requestProxy = async (...args) => {\n  const res = await fetch(...args);\n\n  if (res.ok) {\n    return res.json();\n  }\n\n  throw new Error(res.statusText);\n};\nconst get = (source, path, defaultValue = undefined) => {\n  // a[3].b -> a.3.b\n  const paths = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.');\n  let result = source;\n\n  for (const p of paths) {\n    result = Object(result)[p];\n\n    if (result === undefined) {\n      return defaultValue;\n    }\n  }\n\n  return result;\n};\nfunction omit(object, keys) {\n  const result = Object.assign({}, object);\n\n  for (const key of keys) {\n    delete result[key];\n  }\n\n  return result;\n}\nconst warning = (message, throwError = false) => {\n  const msg = `Warning: [vue-request] ${message}`;\n\n  if (throwError) {\n    return new Error(msg);\n  } else {\n    console.error(msg);\n  }\n};\n\nconst limitTrigger = (fn, timeInterval) => {\n  let running = false;\n  return (...args) => {\n    if (running) return;\n    running = true;\n    fn(...args);\n    setTimeout(() => {\n      running = false;\n    }, timeInterval);\n  };\n};\n\nvar _window;\nconst FOCUS_LISTENER = new Set();\nconst VISIBLE_LISTENER = new Set();\nconst RECONNECT_LISTENER = new Set();\n\nconst subscriber = (listenerType, event) => {\n  let listeners;\n\n  switch (listenerType) {\n    case 'FOCUS_LISTENER':\n      listeners = FOCUS_LISTENER;\n      break;\n\n    case 'RECONNECT_LISTENER':\n      listeners = RECONNECT_LISTENER;\n      break;\n\n    case 'VISIBLE_LISTENER':\n      listeners = VISIBLE_LISTENER;\n      break;\n  }\n\n  if (listeners.has(event)) return;\n  listeners.add(event);\n  return () => {\n    listeners.delete(event);\n  };\n};\n\nconst observer = listeners => {\n  listeners.forEach(event => {\n    event();\n  });\n};\n/* istanbul ignore else */\n\n\nif (!isServer && (_window = window) !== null && _window !== void 0 && _window.addEventListener) {\n  window.addEventListener('visibilitychange', () => {\n    /* istanbul ignore else */\n    if (isDocumentVisibility()) {\n      observer(VISIBLE_LISTENER);\n    }\n  }, false);\n  window.addEventListener('focus', () => observer(FOCUS_LISTENER), false);\n  window.addEventListener('online', () => observer(RECONNECT_LISTENER), false);\n}\n\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n\n  const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      window.cancelAnimationFrame(timerId);\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nfunction baseMerge(origin, target) {\n  for (const key in target) {\n    if (target[key] === undefined) {\n      continue;\n    }\n\n    if (!isObject(target[key]) || // `target[key]` is not an object\n    !isObject(origin[key]) || // `target[key]` is not an object\n    !(key in origin) // `key` is not in the origin object\n    ) {\n        origin[key] = target[key];\n        continue;\n      }\n\n    if (isPlainObject(target[key]) || isArray(target[key])) {\n      baseMerge(origin[key], target[key]);\n    }\n  }\n}\n\nfunction merge(origin, ...others) {\n  const result = Object.assign({}, origin);\n  if (!others.length) return result;\n\n  for (const item of others) {\n    baseMerge(result, item);\n  }\n\n  return result;\n}\n\n/**\r\n * source by `lodash`\r\n * https://github.com/lodash/lodash.git\r\n */\n\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait\n  });\n}\n\nconst setStateBind = (oldState, publicCb) => {\n  return newState => {\n    Object.keys(newState).forEach(key => {\n      oldState[key].value = newState[key];\n    });\n    publicCb.forEach(fun => fun(oldState));\n  };\n};\n\nconst createQuery = (query, config, initialState) => {\n  var _initialState$loading, _initialState$data, _initialState$params;\n\n  const {\n    initialAutoRunFlag,\n    initialData,\n    loadingDelay,\n    pollingInterval,\n    debounceInterval,\n    debounceOptions,\n    throttleInterval,\n    throttleOptions,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    errorRetryCount,\n    errorRetryInterval,\n    stopPollingWhenHiddenOrOffline,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    formatResult,\n    onSuccess,\n    onError,\n    onBefore,\n    onAfter\n  } = config;\n  const retriedCount = ref(0);\n  const loading = ref((_initialState$loading = initialState === null || initialState === void 0 ? void 0 : initialState.loading) !== null && _initialState$loading !== void 0 ? _initialState$loading : false);\n  const data = ref((_initialState$data = initialState === null || initialState === void 0 ? void 0 : initialState.data) !== null && _initialState$data !== void 0 ? _initialState$data : initialData);\n  const error = ref(initialState === null || initialState === void 0 ? void 0 : initialState.error);\n  const params = ref((_initialState$params = initialState === null || initialState === void 0 ? void 0 : initialState.params) !== null && _initialState$params !== void 0 ? _initialState$params : []);\n  const setState = setStateBind({\n    loading,\n    data,\n    error,\n    params\n  }, [state => updateCache(state)]); // reset retried count\n\n  const resetRetriedCount = () => {\n    retriedCount.value = 0;\n  };\n\n  const count = ref(0);\n  const pollingTimer = ref();\n  const retryTimer = ref();\n  const delayLoadingTimer = ref();\n\n  const clearAllTimer = () => {\n    // clear pollingTimer\n    if (pollingTimer.value) {\n      pollingTimer.value();\n    } // clear delayLoadingTimer\n\n\n    if (delayLoadingTimer.value) {\n      delayLoadingTimer.value();\n    } // clear retryTimer\n\n\n    if (retryTimer.value) {\n      retryTimer.value();\n    }\n  };\n\n  const delayLoading = () => {\n    let timerId;\n\n    if (loadingDelay) {\n      timerId = setTimeout(setState, loadingDelay, {\n        loading: true\n      });\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const polling = pollingFunc => {\n    // if errorRetry is enabled, then skip this method\n    if (error.value && errorRetryCount !== 0) return;\n    let timerId;\n\n    if (!isNil(pollingInterval) && pollingInterval >= 0) {\n      if ((pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n        timerId = setTimeout(pollingFunc, pollingInterval);\n      } else {\n        // stop polling\n        stopPollingWhenHiddenOrOffline.value = true;\n        return;\n      }\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const actualErrorRetryInterval = computed(() => {\n    if (errorRetryInterval) return errorRetryInterval;\n    const baseTime = 1000;\n    const minCoefficient = 1;\n    const maxCoefficient = 9; // When retrying for the first time, in order to avoid the coefficient being 0\n    // so replace 0 with 2, the coefficient range will become 1 - 2\n\n    const coefficient = Math.floor(Math.random() * 2 ** Math.min(retriedCount.value, maxCoefficient) + minCoefficient);\n    return baseTime * coefficient;\n  });\n\n  const errorRetryHooks = retryFunc => {\n    let timerId;\n    const isInfiniteRetry = errorRetryCount === -1;\n    const hasRetryCount = retriedCount.value < errorRetryCount; // if errorRetryCount is -1, it will retry the request until it success\n\n    if (error.value && (isInfiniteRetry || hasRetryCount)) {\n      if (!isInfiniteRetry) retriedCount.value += 1;\n      timerId = setTimeout(retryFunc, actualErrorRetryInterval.value);\n    }\n\n    return () => timerId && clearTimeout(timerId);\n  };\n\n  const _run = (...args) => {\n    setState({\n      loading: !loadingDelay,\n      params: args\n    });\n    delayLoadingTimer.value = delayLoading();\n    count.value += 1;\n    const currentCount = count.value; // onBefore hooks\n\n    onBefore === null || onBefore === void 0 ? void 0 : onBefore(args);\n    return query(...args).then(res => {\n      if (currentCount === count.value) {\n        const formattedResult = formatResult ? formatResult(res) : res;\n        setState({\n          data: formattedResult,\n          loading: false,\n          error: undefined\n        });\n\n        if (onSuccess) {\n          onSuccess(formattedResult, args);\n        }\n\n        resetRetriedCount();\n        return formattedResult;\n      }\n\n      return resolvedPromise;\n    }).catch(error => {\n      if (currentCount === count.value) {\n        setState({\n          data: undefined,\n          loading: false,\n          error: error\n        });\n\n        if (onError) {\n          onError(error, args);\n        }\n\n        console.error(error);\n      }\n\n      return resolvedPromise;\n    }).finally(() => {\n      if (currentCount === count.value) {\n        // clear delayLoadingTimer\n        delayLoadingTimer.value(); // retry\n\n        retryTimer.value = errorRetryHooks(() => _run(...args)); // run for polling\n\n        pollingTimer.value = polling(() => _run(...args)); // onAfter hooks\n\n        onAfter === null || onAfter === void 0 ? void 0 : onAfter(args);\n      }\n    });\n  };\n\n  const debouncedRun = !isNil(debounceInterval) && debounce(_run, debounceInterval, debounceOptions);\n  const throttledRun = !isNil(throttleInterval) && throttle(_run, throttleInterval, throttleOptions);\n\n  const run = (...args) => {\n    clearAllTimer(); // initial auto run should not debounce\n\n    if (!initialAutoRunFlag.value && debouncedRun) {\n      debouncedRun(...args);\n      return resolvedPromise;\n    }\n\n    if (throttledRun) {\n      throttledRun(...args);\n      return resolvedPromise;\n    }\n\n    resetRetriedCount();\n    return _run(...args);\n  };\n\n  const cancel = () => {\n    count.value += 1;\n    setState({\n      loading: false\n    });\n\n    if (debouncedRun) {\n      debouncedRun.cancel();\n    }\n\n    if (throttledRun) {\n      throttledRun.cancel();\n    }\n\n    clearAllTimer();\n  };\n\n  const refresh = () => {\n    return run(...params.value);\n  };\n\n  const mutate = x => {\n    const mutateData = isFunction(x) ? x(data.value) : x;\n    setState({\n      data: mutateData\n    });\n  }; // collect subscribers, in order to unsubscribe when the component unmounted\n\n\n  const unsubscribeList = [];\n\n  const addUnsubscribeList = event => {\n    event && unsubscribeList.push(event);\n  };\n\n  const rePolling = () => {\n    if (stopPollingWhenHiddenOrOffline.value && (pollingWhenHidden || isDocumentVisibility()) && (pollingWhenOffline || isOnline())) {\n      refresh();\n      stopPollingWhenHiddenOrOffline.value = false;\n    }\n  }; // subscribe polling\n\n\n  if (!pollingWhenHidden) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', rePolling));\n  } // subscribe online when pollingWhenOffline is false\n\n\n  if (!pollingWhenOffline) {\n    addUnsubscribeList(subscriber('RECONNECT_LISTENER', rePolling));\n  }\n\n  const limitRefresh = limitTrigger(refresh, refocusTimespan); // subscribe window focus or visible\n\n  if (refreshOnWindowFocus) {\n    addUnsubscribeList(subscriber('VISIBLE_LISTENER', limitRefresh));\n    addUnsubscribeList(subscriber('FOCUS_LISTENER', limitRefresh));\n  }\n\n  const unmount = () => {\n    unsubscribeList.forEach(unsubscribe => unsubscribe());\n  };\n\n  return {\n    loading,\n    data,\n    error,\n    params,\n    run,\n    cancel,\n    refresh,\n    mutate,\n    unmount\n  };\n};\n\nconst CACHE_MAP = new Map();\nconst getCache = cacheKey => {\n  if (isNil(cacheKey)) return;\n  const data = CACHE_MAP.get(cacheKey);\n  if (!data) return;\n  return {\n    data: data.data,\n    cacheTime: data.cacheTime\n  };\n};\nconst setCache = (cacheKey, data, cacheTime) => {\n  const oldCache = CACHE_MAP.get(cacheKey);\n\n  if (oldCache !== null && oldCache !== void 0 && oldCache.timer) {\n    clearTimeout(oldCache.timer);\n  }\n\n  const timer = setTimeout(() => CACHE_MAP.delete(cacheKey), cacheTime);\n  CACHE_MAP.set(cacheKey, {\n    data,\n    timer,\n    cacheTime: new Date().getTime()\n  });\n};\n\nconst QUERY_DEFAULT_KEY = '__QUERY_DEFAULT_KEY__';\n\nfunction useAsyncQuery(query, options) {\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    cacheKey,\n    defaultParams = [],\n    manual = false,\n    ready = ref(true),\n    refreshDeps = [],\n    loadingDelay = 0,\n    pollingWhenHidden = false,\n    pollingWhenOffline = false,\n    refreshOnWindowFocus = false,\n    refocusTimespan = 5000,\n    cacheTime = 600000,\n    staleTime = 0,\n    errorRetryCount = 0,\n    errorRetryInterval = 0,\n    queryKey,\n    ...rest\n  } = { ...getGlobalOptions(),\n    ...injectedGlobalOptions,\n    ...options\n  };\n  const stopPollingWhenHiddenOrOffline = ref(false); // skip debounce when initail run\n\n  const initialAutoRunFlag = ref(false);\n\n  const updateCache = state => {\n    var _getCache, _queryKey;\n\n    if (!cacheKey) return;\n    const cacheData = (_getCache = getCache(cacheKey)) === null || _getCache === void 0 ? void 0 : _getCache.data;\n    const cacheQueries = cacheData === null || cacheData === void 0 ? void 0 : cacheData.queries;\n    const queryData = unRefObject(state);\n    const currentQueryKey = (_queryKey = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...state.params.value)) !== null && _queryKey !== void 0 ? _queryKey : QUERY_DEFAULT_KEY;\n    setCache(cacheKey, {\n      queries: { ...cacheQueries,\n        [currentQueryKey]: { ...(cacheQueries === null || cacheQueries === void 0 ? void 0 : cacheQueries[currentQueryKey]),\n          ...queryData\n        }\n      },\n      latestQueriesKey: currentQueryKey\n    }, cacheTime);\n  };\n\n  const config = {\n    initialAutoRunFlag,\n    loadingDelay,\n    pollingWhenHidden,\n    pollingWhenOffline,\n    stopPollingWhenHiddenOrOffline,\n    cacheKey,\n    errorRetryCount,\n    errorRetryInterval,\n    refreshOnWindowFocus,\n    refocusTimespan,\n    updateCache,\n    ...omit(rest, ['pagination', 'listKey'])\n  };\n  const loading = ref(false);\n  const data = ref();\n  const error = ref();\n  const params = ref();\n  const queries = reactive({\n    [QUERY_DEFAULT_KEY]: reactive(createQuery(query, config))\n  });\n  const latestQueriesKey = ref(QUERY_DEFAULT_KEY);\n  const latestQuery = computed(() => {\n    var _queries$latestQuerie;\n\n    return (_queries$latestQuerie = queries[latestQueriesKey.value]) !== null && _queries$latestQuerie !== void 0 ? _queries$latestQuerie : {};\n  }); // sync state\n\n  watch(latestQuery, queryData => {\n    loading.value = queryData.loading;\n    data.value = queryData.data;\n    error.value = queryData.error;\n    params.value = queryData.params;\n  }, {\n    immediate: true,\n    deep: true\n  }); // init queries from cache\n\n  if (cacheKey) {\n    var _cache$data;\n\n    const cache = getCache(cacheKey);\n\n    if (cache !== null && cache !== void 0 && (_cache$data = cache.data) !== null && _cache$data !== void 0 && _cache$data.queries) {\n      Object.keys(cache.data.queries).forEach(key => {\n        const cacheQuery = cache.data.queries[key];\n        queries[key] = reactive(createQuery(query, config, {\n          loading: cacheQuery.loading,\n          params: cacheQuery.params,\n          data: cacheQuery.data,\n          error: cacheQuery.error\n        }));\n      });\n      /* istanbul ignore else */\n\n      if (cache.data.latestQueriesKey) {\n        latestQueriesKey.value = cache.data.latestQueriesKey;\n      }\n    }\n  }\n\n  const tempReadyParams = ref();\n  const hasTriggerReady = ref(false);\n\n  const run = (...args) => {\n    var _queryKey2;\n\n    if (!ready.value && !hasTriggerReady.value) {\n      tempReadyParams.value = args;\n      return resolvedPromise;\n    }\n\n    const newKey = (_queryKey2 = queryKey === null || queryKey === void 0 ? void 0 : queryKey(...args)) !== null && _queryKey2 !== void 0 ? _queryKey2 : QUERY_DEFAULT_KEY;\n\n    if (!queries[newKey]) {\n      queries[newKey] = reactive(createQuery(query, config));\n    }\n\n    latestQueriesKey.value = newKey;\n    return latestQuery.value.run(...args);\n  };\n\n  const reset = () => {\n    unmountQueries();\n    latestQueriesKey.value = QUERY_DEFAULT_KEY;\n    queries[QUERY_DEFAULT_KEY] = reactive(createQuery(query, config));\n  }; // unmount queries\n\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      queries[key].cancel();\n      queries[key].unmount();\n      delete queries[key];\n    });\n  };\n\n  const cancel = () => latestQuery.value.cancel();\n\n  const refresh = () => latestQuery.value.refresh();\n\n  const mutate = arg => latestQuery.value.mutate(arg); // initial run\n\n\n  if (!manual) {\n    var _cache$data$queries;\n\n    initialAutoRunFlag.value = true; // TODO: need refactor\n\n    const cache = getCache(cacheKey);\n    const cacheQueries = (_cache$data$queries = cache === null || cache === void 0 ? void 0 : cache.data.queries) !== null && _cache$data$queries !== void 0 ? _cache$data$queries : {};\n    const isFresh = cache && (staleTime === -1 || cache.cacheTime + staleTime > new Date().getTime());\n    const hasCacheQueries = Object.keys(cacheQueries).length > 0;\n\n    if (!isFresh) {\n      if (hasCacheQueries) {\n        Object.keys(queries).forEach(key => {\n          var _queries$key;\n\n          (_queries$key = queries[key]) === null || _queries$key === void 0 ? void 0 : _queries$key.refresh();\n        });\n      } else {\n        run(...defaultParams);\n      }\n    }\n\n    initialAutoRunFlag.value = false;\n  } // watch ready\n\n\n  const stopReady = ref();\n  stopReady.value = watch(ready, val => {\n    hasTriggerReady.value = true;\n\n    if (val && tempReadyParams.value) {\n      run(...tempReadyParams.value); // destroy current watch\n\n      stopReady.value();\n    }\n  }, {\n    flush: 'sync'\n  }); // watch refreshDeps\n\n  if (refreshDeps.length) {\n    watch(refreshDeps, () => {\n      !manual && latestQuery.value.refresh();\n    });\n  }\n\n  onUnmounted(() => {\n    unmountQueries();\n  });\n  return {\n    loading,\n    data,\n    error,\n    params,\n    cancel,\n    refresh,\n    mutate,\n    run,\n    reset,\n    queries\n  };\n}\n\nconst generateService = service => {\n  return (...args) => {\n    if (isFunction(service)) {\n      return generateService(service(...args))();\n    } else if (isPromise(service)) {\n      return service;\n    } else if (isPlainObject(service)) {\n      const {\n        url,\n        ...rest\n      } = service;\n      return requestProxy(url, rest);\n    } else if (isString(service)) {\n      return requestProxy(service);\n    } else {\n      throw warning('Unknown service type', true);\n    }\n  };\n};\n\nfunction useLoadMore(service, options) {\n  var _injectedGlobalOption;\n\n  if (!isFunction(service)) {\n    warning('useLoadMore only support function service');\n  }\n\n  const promiseQuery = generateService(service);\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    queryKey,\n    isNoMore,\n    listKey = 'list',\n    ...restOptions\n  } = Object.assign({\n    listKey: (_injectedGlobalOption = injectedGlobalOptions.listKey) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : getGlobalOptions().listKey\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('useLoadMore does not support concurrent request');\n  }\n\n  const refreshing = ref(false);\n  const loadingMore = ref(false);\n  const reloading = ref(false);\n  const initailIncreaseQueryKey = 0;\n  const increaseQueryKey = ref(initailIncreaseQueryKey);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    cancel: _cancel,\n    ...rest\n  } = useAsyncQuery(promiseQuery, { ...restOptions,\n    onSuccess: (...p) => {\n      var _restOptions$onSucces;\n\n      loadingMore.value = false;\n      increaseQueryKey.value++;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onSucces = restOptions.onSuccess) === null || _restOptions$onSucces === void 0 ? void 0 : _restOptions$onSucces.call(restOptions, ...p);\n    },\n    onError: (...p) => {\n      var _restOptions$onError;\n\n      loadingMore.value = false;\n      restOptions === null || restOptions === void 0 ? void 0 : (_restOptions$onError = restOptions.onError) === null || _restOptions$onError === void 0 ? void 0 : _restOptions$onError.call(restOptions, ...p);\n    },\n    queryKey: () => String(increaseQueryKey.value)\n  });\n  const latestData = ref(data.value);\n  watchEffect(() => {\n    if (data.value !== undefined) {\n      latestData.value = data.value;\n    }\n  });\n  const noMore = computed(() => {\n    return isNoMore && isFunction(isNoMore) ? isNoMore(latestData.value) : false;\n  });\n  const dataList = computed(() => {\n    let list = [];\n    Object.values(queries).forEach(h => {\n      const dataList = get(h.data, listKey);\n\n      if (dataList && Array.isArray(dataList)) {\n        list = list.concat(dataList);\n      }\n    });\n    return list;\n  });\n\n  const loadMore = () => {\n    if (noMore.value) {\n      return;\n    }\n\n    loadingMore.value = true;\n    const [, ...restParams] = params.value;\n    const mergerParams = [{\n      dataList: dataList.value,\n      data: latestData.value\n    }, ...restParams];\n    run(...mergerParams);\n  };\n\n  const unmountQueries = () => {\n    Object.keys(queries).forEach(key => {\n      if (key !== initailIncreaseQueryKey.toString()) {\n        queries[key].cancel();\n        queries[key].unmount();\n        delete queries[key];\n      }\n    });\n  };\n\n  const refresh = async () => {\n    refreshing.value = true;\n    const latestKey = increaseQueryKey.value - 1;\n    const key = latestKey < initailIncreaseQueryKey ? initailIncreaseQueryKey : latestKey;\n    latestData.value = queries[key].data;\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    unmountQueries();\n    refreshing.value = false;\n  };\n\n  const reload = async () => {\n    reloading.value = true;\n    reset();\n    increaseQueryKey.value = initailIncreaseQueryKey;\n    latestData.value = undefined;\n    const [, ...restParams] = params.value;\n    const mergerParams = [undefined, ...restParams];\n    await run(...mergerParams);\n    reloading.value = false;\n  };\n\n  const cancel = () => {\n    _cancel();\n\n    loadingMore.value = false;\n    refreshing.value = false;\n  };\n\n  return {\n    data: latestData,\n    dataList: dataList,\n    params,\n    noMore,\n    loadingMore,\n    refreshing,\n    reloading,\n    run,\n    reload,\n    loadMore,\n    reset,\n    refresh,\n    cancel,\n    ...omit(rest, ['refresh', 'mutate'])\n  };\n}\n\nfunction usePagination(service, options) {\n  var _getGlobalOptions$pag, _injectedGlobalOption;\n\n  const promiseQuery = generateService(service);\n  const defaultOptions = {\n    pagination: {\n      currentKey: 'current',\n      pageSizeKey: 'pageSize',\n      totalKey: 'total',\n      totalPageKey: 'totalPage'\n    }\n  };\n  const injectedGlobalOptions = inject(GLOBAL_OPTIONS_PROVIDE_KEY, {});\n  const {\n    pagination: {\n      currentKey,\n      pageSizeKey,\n      totalKey,\n      totalPageKey\n    },\n    queryKey,\n    ...restOptions\n  } = merge(defaultOptions, {\n    pagination: (_getGlobalOptions$pag = getGlobalOptions().pagination) !== null && _getGlobalOptions$pag !== void 0 ? _getGlobalOptions$pag : {}\n  }, {\n    pagination: (_injectedGlobalOption = injectedGlobalOptions.pagination) !== null && _injectedGlobalOption !== void 0 ? _injectedGlobalOption : {}\n  }, options !== null && options !== void 0 ? options : {});\n\n  if (queryKey) {\n    warning('usePagination does not support concurrent request');\n  }\n\n  const finallyOptions = merge({\n    defaultParams: [{\n      [currentKey]: 1,\n      [pageSizeKey]: 10\n    }]\n  }, restOptions);\n  const {\n    data,\n    params,\n    queries,\n    run,\n    reset,\n    ...rest\n  } = useAsyncQuery(promiseQuery, finallyOptions);\n\n  const paging = paginationParams => {\n    const [oldPaginationParams, ...restParams] = params.value;\n    const newPaginationParams = { ...oldPaginationParams,\n      ...paginationParams\n    };\n    const mergerParams = [newPaginationParams, ...restParams];\n    run(...mergerParams);\n  }; // changeCurrent\tchange current page\t(current: number) => void\n\n\n  const changeCurrent = current => {\n    paging({\n      [currentKey]: current\n    });\n  }; // changePageSize\tchange pageSize\t(pageSize: number) => void\n\n\n  const changePageSize = pageSize => {\n    paging({\n      [pageSizeKey]: pageSize\n    });\n  }; // changePagination\tchange current and pageSize\t(current: number, pageSize: number) => void\n\n\n  const changePagination = (current, pageSize) => {\n    paging({\n      [currentKey]: current,\n      [pageSizeKey]: pageSize\n    });\n  };\n\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams,\n      manual\n    } = finallyOptions;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  const total = computed(() => get(data.value, totalKey, 0));\n  const current = computed({\n    get: () => {\n      var _params$value$0$curre, _params$value$;\n\n      return (_params$value$0$curre = (_params$value$ = params.value[0]) === null || _params$value$ === void 0 ? void 0 : _params$value$[currentKey]) !== null && _params$value$0$curre !== void 0 ? _params$value$0$curre : finallyOptions.defaultParams[0][currentKey];\n    },\n    set: val => {\n      changeCurrent(val);\n    }\n  });\n  const pageSize = computed({\n    get: () => {\n      var _params$value$0$pageS, _params$value$2;\n\n      return (_params$value$0$pageS = (_params$value$2 = params.value[0]) === null || _params$value$2 === void 0 ? void 0 : _params$value$2[pageSizeKey]) !== null && _params$value$0$pageS !== void 0 ? _params$value$0$pageS : finallyOptions.defaultParams[0][pageSizeKey];\n    },\n    set: val => {\n      changePageSize(val);\n    }\n  });\n  const totalPage = computed(() => get(data.value, totalPageKey, Math.ceil(total.value / pageSize.value)));\n  return {\n    data,\n    params,\n    current,\n    pageSize,\n    total,\n    totalPage,\n    reloading,\n    run,\n    changeCurrent,\n    changePageSize,\n    changePagination,\n    reload,\n    ...rest\n  };\n}\n\nfunction useRequest(service, options) {\n  const promiseQuery = generateService(service);\n  const {\n    reset,\n    run,\n    ...rest\n  } = useAsyncQuery(promiseQuery, options !== null && options !== void 0 ? options : {});\n  const reloading = ref(false);\n\n  const reload = async () => {\n    const {\n      defaultParams = [],\n      manual\n    } = options;\n    reset();\n\n    if (!manual) {\n      reloading.value = true;\n      await run(...defaultParams);\n      reloading.value = false;\n    }\n  };\n\n  return {\n    reload,\n    run,\n    reloading,\n    ...rest\n  };\n}\n\nexport { RequestConfig, setGlobalOptions, useLoadMore, usePagination, useRequest };\n"]},"metadata":{},"sourceType":"module"}