{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport warning from 'warning';\nimport { convertDataToTree as vcConvertDataToTree, convertTreeToEntities as vcConvertTreeToEntities, conductCheck as rcConductCheck } from '../../vc-tree/src/util';\nimport { hasClass } from '../../vc-util/Dom/class';\nimport { SHOW_CHILD, SHOW_PARENT } from './strategies';\nimport { getSlot, getPropsData, isEmptyElement } from '../../_util/props-util';\nvar warnDeprecatedLabel = false; // =================== DOM =====================\n\nexport function findPopupContainer(node, prefixClass) {\n  var current = node;\n\n  while (current) {\n    if (hasClass(current, prefixClass)) {\n      return current;\n    }\n\n    current = current.parentNode;\n  }\n\n  return null;\n} // =================== MISC ====================\n\nexport function toTitle(title) {\n  if (typeof title === 'string') {\n    return title;\n  }\n\n  return null;\n}\nexport function toArray(data) {\n  if (data === undefined || data === null) return [];\n  return Array.isArray(data) ? data : [data];\n}\nexport function createRef() {\n  var func = function setRef(node) {\n    func.current = node;\n  };\n\n  return func;\n} // =============== Legacy ===============\n\nexport var UNSELECTABLE_STYLE = {\n  userSelect: 'none',\n  WebkitUserSelect: 'none'\n};\nexport var UNSELECTABLE_ATTRIBUTE = {\n  unselectable: 'unselectable'\n};\n/**\n * Convert position list to hierarchy structure.\n * This is little hack since use '-' to split the position.\n */\n\nexport function flatToHierarchy(positionList) {\n  if (!positionList.length) {\n    return [];\n  }\n\n  var entrances = {}; // Prepare the position map\n\n  var posMap = {};\n  var parsedList = positionList.slice().map(function (entity) {\n    var clone = _extends(_extends({}, entity), {\n      fields: entity.pos.split('-')\n    });\n\n    delete clone.children;\n    return clone;\n  });\n  parsedList.forEach(function (entity) {\n    posMap[entity.pos] = entity;\n  });\n  parsedList.sort(function (a, b) {\n    return a.fields.length - b.fields.length;\n  }); // Create the hierarchy\n\n  parsedList.forEach(function (entity) {\n    var parentPos = entity.fields.slice(0, -1).join('-');\n    var parentEntity = posMap[parentPos];\n\n    if (!parentEntity) {\n      entrances[entity.pos] = entity;\n    } else {\n      parentEntity.children = parentEntity.children || [];\n      parentEntity.children.push(entity);\n    } // Some time position list provide `key`, we don't need it\n\n\n    delete entity.key;\n    delete entity.fields;\n  });\n  return Object.keys(entrances).map(function (key) {\n    return entrances[key];\n  });\n} // =============== Accessibility ===============\n\nvar ariaId = 0;\nexport function resetAriaId() {\n  ariaId = 0;\n}\nexport function generateAriaId(prefix) {\n  ariaId += 1;\n  return \"\".concat(prefix, \"_\").concat(ariaId);\n}\nexport function isLabelInValue(props) {\n  var treeCheckable = props.treeCheckable,\n      treeCheckStrictly = props.treeCheckStrictly,\n      labelInValue = props.labelInValue;\n\n  if (treeCheckable && treeCheckStrictly) {\n    return true;\n  }\n\n  return labelInValue || false;\n} // =================== Tree ====================\n\nexport function parseSimpleTreeData(treeData, _ref) {\n  var id = _ref.id,\n      pId = _ref.pId,\n      rootPId = _ref.rootPId;\n  var keyNodes = {};\n  var rootNodeList = []; // Fill in the map\n\n  var nodeList = treeData.map(function (node) {\n    var clone = _extends({}, node);\n\n    var key = clone[id];\n    keyNodes[key] = clone;\n    clone.key = clone.key || key;\n    return clone;\n  }); // Connect tree\n\n  nodeList.forEach(function (node) {\n    var parentKey = node[pId];\n    var parent = keyNodes[parentKey]; // Fill parent\n\n    if (parent) {\n      parent.children = parent.children || [];\n      parent.children.push(node);\n    } // Fill root tree node\n\n\n    if (parentKey === rootPId || !parent && rootPId === null) {\n      rootNodeList.push(node);\n    }\n  });\n  return rootNodeList;\n}\n/**\n * Detect if position has relation.\n * e.g. 1-2 related with 1-2-3\n * e.g. 1-3-2 related with 1\n * e.g. 1-2 not related with 1-21\n */\n\nexport function isPosRelated(pos1, pos2) {\n  var fields1 = pos1.split('-');\n  var fields2 = pos2.split('-');\n  var minLen = Math.min(fields1.length, fields2.length);\n\n  for (var i = 0; i < minLen; i += 1) {\n    if (fields1[i] !== fields2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * This function is only used on treeNode check (none treeCheckStrictly but has searchInput).\n * We convert entity to { node, pos, children } format.\n * This is legacy bug but we still need to do with it.\n * @param entity\n */\n\nexport function cleanEntity(_ref2) {\n  var node = _ref2.node,\n      pos = _ref2.pos,\n      children = _ref2.children;\n  var instance = {\n    node: node,\n    pos: pos\n  };\n\n  if (children) {\n    instance.children = children.map(cleanEntity);\n  }\n\n  return instance;\n}\n/**\n * Get a filtered TreeNode list by provided treeNodes.\n * [Legacy] Since `Tree` use `key` as map but `key` will changed by React,\n * we have to convert `treeNodes > data > treeNodes` to keep the key.\n * Such performance hungry!\n */\n\nexport function getFilterTree(treeNodes, searchValue, filterFunc, valueEntities, Component) {\n  if (!searchValue) {\n    return null;\n  }\n\n  function mapFilteredNodeToData(node) {\n    if (!node || isEmptyElement(node)) return null;\n    var match = false;\n\n    if (filterFunc(searchValue, node)) {\n      match = true;\n    }\n\n    var children = getSlot(node);\n    children = ((typeof children === 'function' ? children() : children) || []).map(mapFilteredNodeToData).filter(function (n) {\n      return n;\n    });\n\n    if (children.length || match) {\n      return _createVNode(Component, _objectSpread(_objectSpread({}, node.props), {}, {\n        \"key\": valueEntities[getPropsData(node).value].key\n      }), {\n        default: function _default() {\n          return [children];\n        }\n      });\n    }\n\n    return null;\n  }\n\n  return treeNodes.map(mapFilteredNodeToData).filter(function (node) {\n    return node;\n  });\n} // =================== Value ===================\n\n/**\n * Convert value to array format to make logic simplify.\n */\n\nexport function formatInternalValue(value, props) {\n  var valueList = toArray(value); // Parse label in value\n\n  if (isLabelInValue(props)) {\n    return valueList.map(function (val) {\n      if (_typeof(val) !== 'object' || !val) {\n        return {\n          value: '',\n          label: ''\n        };\n      }\n\n      return val;\n    });\n  }\n\n  return valueList.map(function (val) {\n    return {\n      value: val\n    };\n  });\n}\nexport function getLabel(wrappedValue, entity, treeNodeLabelProp) {\n  if (wrappedValue.label) {\n    return wrappedValue.label;\n  }\n\n  if (entity) {\n    var props = getPropsData(entity.node);\n\n    if (Object.keys(props).length) {\n      return props[treeNodeLabelProp];\n    }\n  } // Since value without entity will be in missValueList.\n  // This code will never reached, but we still need this in case.\n\n\n  return wrappedValue.value;\n}\n/**\n * Convert internal state `valueList` to user needed value list.\n * This will return an array list. You need check if is not multiple when return.\n *\n * `allCheckedNodes` is used for `treeCheckStrictly`\n */\n\nexport function formatSelectorValue(valueList, props, valueEntities) {\n  var treeNodeLabelProp = props.treeNodeLabelProp,\n      treeCheckable = props.treeCheckable,\n      treeCheckStrictly = props.treeCheckStrictly,\n      showCheckedStrategy = props.showCheckedStrategy; // Will hide some value if `showCheckedStrategy` is set\n\n  if (treeCheckable && !treeCheckStrictly) {\n    var values = {};\n    valueList.forEach(function (wrappedValue) {\n      values[wrappedValue.value] = wrappedValue;\n    });\n    var hierarchyList = flatToHierarchy(valueList.map(function (_ref3) {\n      var value = _ref3.value;\n      return valueEntities[value];\n    }));\n\n    if (showCheckedStrategy === SHOW_PARENT) {\n      // Only get the parent checked value\n      return hierarchyList.map(function (_ref4) {\n        var node = _ref4.node;\n        var value = getPropsData(node).value;\n        return {\n          label: getLabel(values[value], valueEntities[value], treeNodeLabelProp),\n          value: value\n        };\n      });\n    }\n\n    if (showCheckedStrategy === SHOW_CHILD) {\n      // Only get the children checked value\n      var targetValueList = []; // Find the leaf children\n\n      var traverse = function traverse(_ref5) {\n        var node = _ref5.node,\n            children = _ref5.children;\n        var value = getPropsData(node).value;\n\n        if (!children || children.length === 0) {\n          targetValueList.push({\n            label: getLabel(values[value], valueEntities[value], treeNodeLabelProp),\n            value: value\n          });\n          return;\n        }\n\n        children.forEach(function (entity) {\n          traverse(entity);\n        });\n      };\n\n      hierarchyList.forEach(function (entity) {\n        traverse(entity);\n      });\n      return targetValueList;\n    }\n  }\n\n  return valueList.map(function (wrappedValue) {\n    return {\n      label: getLabel(wrappedValue, valueEntities[wrappedValue.value], treeNodeLabelProp),\n      value: wrappedValue.value\n    };\n  });\n}\n/**\n * Use `rc-tree` convertDataToTree to convert treeData to TreeNodes.\n * This will change the label to title value\n */\n\nfunction processProps(props) {\n  var title = props.title,\n      label = props.label,\n      key = props.key,\n      value = props.value;\n\n  var cloneProps = _extends({}, props); // Warning user not to use deprecated label prop.\n\n\n  if (label && !title) {\n    if (!warnDeprecatedLabel) {\n      warning(false, \"'label' in treeData is deprecated. Please use 'title' instead.\");\n      warnDeprecatedLabel = true;\n    }\n\n    cloneProps.title = label;\n  }\n\n  if (!key && (key === undefined || key === null)) {\n    cloneProps.key = value;\n  }\n\n  return cloneProps;\n}\n\nexport function convertDataToTree(treeData) {\n  return vcConvertDataToTree(treeData, {\n    processProps: processProps\n  });\n}\n/**\n * Use `rc-tree` convertTreeToEntities for entities calculation.\n * We have additional entities of `valueEntities`\n */\n\nfunction initWrapper(wrapper) {\n  return _extends(_extends({}, wrapper), {\n    valueEntities: {}\n  });\n}\n\nfunction processEntity(entity, wrapper) {\n  var value = getPropsData(entity.node).value;\n  entity.value = value; // This should be empty, or will get error message.\n\n  var currentEntity = wrapper.valueEntities[value];\n\n  if (currentEntity) {\n    warning(false, \"Conflict! value of node '\".concat(entity.key, \"' (\").concat(value, \") has already used by node '\").concat(currentEntity.key, \"'.\"));\n  }\n\n  wrapper.valueEntities[value] = entity;\n}\n\nexport function convertTreeToEntities(treeNodes) {\n  return vcConvertTreeToEntities(treeNodes, {\n    initWrapper: initWrapper,\n    processEntity: processEntity\n  });\n}\n/**\n * https://github.com/ant-design/ant-design/issues/13328\n * We need calculate the half check key when searchValue is set.\n */\n// TODO: This logic may better move to rc-tree\n\nexport function getHalfCheckedKeys(valueList, valueEntities) {\n  var values = {}; // Fill checked keys\n\n  valueList.forEach(function (_ref6) {\n    var value = _ref6.value;\n    values[value] = false;\n  }); // Fill half checked keys\n\n  valueList.forEach(function (_ref7) {\n    var value = _ref7.value;\n    var current = valueEntities[value];\n\n    while (current && current.parent) {\n      var parentValue = current.parent.value;\n      if (parentValue in values) break;\n      values[parentValue] = true;\n      current = current.parent;\n    }\n  }); // Get half keys\n\n  return Object.keys(values).filter(function (value) {\n    return values[value];\n  }).map(function (value) {\n    return valueEntities[value].key;\n  });\n}\nexport var conductCheck = rcConductCheck;","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/node_modules/ant-design-vue/es/vc-tree-select/src/util.js"],"names":["_typeof","_objectSpread","_extends","createVNode","_createVNode","warning","convertDataToTree","vcConvertDataToTree","convertTreeToEntities","vcConvertTreeToEntities","conductCheck","rcConductCheck","hasClass","SHOW_CHILD","SHOW_PARENT","getSlot","getPropsData","isEmptyElement","warnDeprecatedLabel","findPopupContainer","node","prefixClass","current","parentNode","toTitle","title","toArray","data","undefined","Array","isArray","createRef","func","setRef","UNSELECTABLE_STYLE","userSelect","WebkitUserSelect","UNSELECTABLE_ATTRIBUTE","unselectable","flatToHierarchy","positionList","length","entrances","posMap","parsedList","slice","map","entity","clone","fields","pos","split","children","forEach","sort","a","b","parentPos","join","parentEntity","push","key","Object","keys","ariaId","resetAriaId","generateAriaId","prefix","concat","isLabelInValue","props","treeCheckable","treeCheckStrictly","labelInValue","parseSimpleTreeData","treeData","_ref","id","pId","rootPId","keyNodes","rootNodeList","nodeList","parentKey","parent","isPosRelated","pos1","pos2","fields1","fields2","minLen","Math","min","i","cleanEntity","_ref2","instance","getFilterTree","treeNodes","searchValue","filterFunc","valueEntities","Component","mapFilteredNodeToData","match","filter","n","value","default","_default","formatInternalValue","valueList","val","label","getLabel","wrappedValue","treeNodeLabelProp","formatSelectorValue","showCheckedStrategy","values","hierarchyList","_ref3","_ref4","targetValueList","traverse","_ref5","processProps","cloneProps","initWrapper","wrapper","processEntity","currentEntity","getHalfCheckedKeys","_ref6","_ref7","parentValue"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport warning from 'warning';\nimport { convertDataToTree as vcConvertDataToTree, convertTreeToEntities as vcConvertTreeToEntities, conductCheck as rcConductCheck } from '../../vc-tree/src/util';\nimport { hasClass } from '../../vc-util/Dom/class';\nimport { SHOW_CHILD, SHOW_PARENT } from './strategies';\nimport { getSlot, getPropsData, isEmptyElement } from '../../_util/props-util';\nvar warnDeprecatedLabel = false; // =================== DOM =====================\n\nexport function findPopupContainer(node, prefixClass) {\n  var current = node;\n\n  while (current) {\n    if (hasClass(current, prefixClass)) {\n      return current;\n    }\n\n    current = current.parentNode;\n  }\n\n  return null;\n} // =================== MISC ====================\n\nexport function toTitle(title) {\n  if (typeof title === 'string') {\n    return title;\n  }\n\n  return null;\n}\nexport function toArray(data) {\n  if (data === undefined || data === null) return [];\n  return Array.isArray(data) ? data : [data];\n}\nexport function createRef() {\n  var func = function setRef(node) {\n    func.current = node;\n  };\n\n  return func;\n} // =============== Legacy ===============\n\nexport var UNSELECTABLE_STYLE = {\n  userSelect: 'none',\n  WebkitUserSelect: 'none'\n};\nexport var UNSELECTABLE_ATTRIBUTE = {\n  unselectable: 'unselectable'\n};\n/**\n * Convert position list to hierarchy structure.\n * This is little hack since use '-' to split the position.\n */\n\nexport function flatToHierarchy(positionList) {\n  if (!positionList.length) {\n    return [];\n  }\n\n  var entrances = {}; // Prepare the position map\n\n  var posMap = {};\n  var parsedList = positionList.slice().map(function (entity) {\n    var clone = _extends(_extends({}, entity), {\n      fields: entity.pos.split('-')\n    });\n\n    delete clone.children;\n    return clone;\n  });\n  parsedList.forEach(function (entity) {\n    posMap[entity.pos] = entity;\n  });\n  parsedList.sort(function (a, b) {\n    return a.fields.length - b.fields.length;\n  }); // Create the hierarchy\n\n  parsedList.forEach(function (entity) {\n    var parentPos = entity.fields.slice(0, -1).join('-');\n    var parentEntity = posMap[parentPos];\n\n    if (!parentEntity) {\n      entrances[entity.pos] = entity;\n    } else {\n      parentEntity.children = parentEntity.children || [];\n      parentEntity.children.push(entity);\n    } // Some time position list provide `key`, we don't need it\n\n\n    delete entity.key;\n    delete entity.fields;\n  });\n  return Object.keys(entrances).map(function (key) {\n    return entrances[key];\n  });\n} // =============== Accessibility ===============\n\nvar ariaId = 0;\nexport function resetAriaId() {\n  ariaId = 0;\n}\nexport function generateAriaId(prefix) {\n  ariaId += 1;\n  return \"\".concat(prefix, \"_\").concat(ariaId);\n}\nexport function isLabelInValue(props) {\n  var treeCheckable = props.treeCheckable,\n      treeCheckStrictly = props.treeCheckStrictly,\n      labelInValue = props.labelInValue;\n\n  if (treeCheckable && treeCheckStrictly) {\n    return true;\n  }\n\n  return labelInValue || false;\n} // =================== Tree ====================\n\nexport function parseSimpleTreeData(treeData, _ref) {\n  var id = _ref.id,\n      pId = _ref.pId,\n      rootPId = _ref.rootPId;\n  var keyNodes = {};\n  var rootNodeList = []; // Fill in the map\n\n  var nodeList = treeData.map(function (node) {\n    var clone = _extends({}, node);\n\n    var key = clone[id];\n    keyNodes[key] = clone;\n    clone.key = clone.key || key;\n    return clone;\n  }); // Connect tree\n\n  nodeList.forEach(function (node) {\n    var parentKey = node[pId];\n    var parent = keyNodes[parentKey]; // Fill parent\n\n    if (parent) {\n      parent.children = parent.children || [];\n      parent.children.push(node);\n    } // Fill root tree node\n\n\n    if (parentKey === rootPId || !parent && rootPId === null) {\n      rootNodeList.push(node);\n    }\n  });\n  return rootNodeList;\n}\n/**\n * Detect if position has relation.\n * e.g. 1-2 related with 1-2-3\n * e.g. 1-3-2 related with 1\n * e.g. 1-2 not related with 1-21\n */\n\nexport function isPosRelated(pos1, pos2) {\n  var fields1 = pos1.split('-');\n  var fields2 = pos2.split('-');\n  var minLen = Math.min(fields1.length, fields2.length);\n\n  for (var i = 0; i < minLen; i += 1) {\n    if (fields1[i] !== fields2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * This function is only used on treeNode check (none treeCheckStrictly but has searchInput).\n * We convert entity to { node, pos, children } format.\n * This is legacy bug but we still need to do with it.\n * @param entity\n */\n\nexport function cleanEntity(_ref2) {\n  var node = _ref2.node,\n      pos = _ref2.pos,\n      children = _ref2.children;\n  var instance = {\n    node: node,\n    pos: pos\n  };\n\n  if (children) {\n    instance.children = children.map(cleanEntity);\n  }\n\n  return instance;\n}\n/**\n * Get a filtered TreeNode list by provided treeNodes.\n * [Legacy] Since `Tree` use `key` as map but `key` will changed by React,\n * we have to convert `treeNodes > data > treeNodes` to keep the key.\n * Such performance hungry!\n */\n\nexport function getFilterTree(treeNodes, searchValue, filterFunc, valueEntities, Component) {\n  if (!searchValue) {\n    return null;\n  }\n\n  function mapFilteredNodeToData(node) {\n    if (!node || isEmptyElement(node)) return null;\n    var match = false;\n\n    if (filterFunc(searchValue, node)) {\n      match = true;\n    }\n\n    var children = getSlot(node);\n    children = ((typeof children === 'function' ? children() : children) || []).map(mapFilteredNodeToData).filter(function (n) {\n      return n;\n    });\n\n    if (children.length || match) {\n      return _createVNode(Component, _objectSpread(_objectSpread({}, node.props), {}, {\n        \"key\": valueEntities[getPropsData(node).value].key\n      }), {\n        default: function _default() {\n          return [children];\n        }\n      });\n    }\n\n    return null;\n  }\n\n  return treeNodes.map(mapFilteredNodeToData).filter(function (node) {\n    return node;\n  });\n} // =================== Value ===================\n\n/**\n * Convert value to array format to make logic simplify.\n */\n\nexport function formatInternalValue(value, props) {\n  var valueList = toArray(value); // Parse label in value\n\n  if (isLabelInValue(props)) {\n    return valueList.map(function (val) {\n      if (_typeof(val) !== 'object' || !val) {\n        return {\n          value: '',\n          label: ''\n        };\n      }\n\n      return val;\n    });\n  }\n\n  return valueList.map(function (val) {\n    return {\n      value: val\n    };\n  });\n}\nexport function getLabel(wrappedValue, entity, treeNodeLabelProp) {\n  if (wrappedValue.label) {\n    return wrappedValue.label;\n  }\n\n  if (entity) {\n    var props = getPropsData(entity.node);\n\n    if (Object.keys(props).length) {\n      return props[treeNodeLabelProp];\n    }\n  } // Since value without entity will be in missValueList.\n  // This code will never reached, but we still need this in case.\n\n\n  return wrappedValue.value;\n}\n/**\n * Convert internal state `valueList` to user needed value list.\n * This will return an array list. You need check if is not multiple when return.\n *\n * `allCheckedNodes` is used for `treeCheckStrictly`\n */\n\nexport function formatSelectorValue(valueList, props, valueEntities) {\n  var treeNodeLabelProp = props.treeNodeLabelProp,\n      treeCheckable = props.treeCheckable,\n      treeCheckStrictly = props.treeCheckStrictly,\n      showCheckedStrategy = props.showCheckedStrategy; // Will hide some value if `showCheckedStrategy` is set\n\n  if (treeCheckable && !treeCheckStrictly) {\n    var values = {};\n    valueList.forEach(function (wrappedValue) {\n      values[wrappedValue.value] = wrappedValue;\n    });\n    var hierarchyList = flatToHierarchy(valueList.map(function (_ref3) {\n      var value = _ref3.value;\n      return valueEntities[value];\n    }));\n\n    if (showCheckedStrategy === SHOW_PARENT) {\n      // Only get the parent checked value\n      return hierarchyList.map(function (_ref4) {\n        var node = _ref4.node;\n        var value = getPropsData(node).value;\n        return {\n          label: getLabel(values[value], valueEntities[value], treeNodeLabelProp),\n          value: value\n        };\n      });\n    }\n\n    if (showCheckedStrategy === SHOW_CHILD) {\n      // Only get the children checked value\n      var targetValueList = []; // Find the leaf children\n\n      var traverse = function traverse(_ref5) {\n        var node = _ref5.node,\n            children = _ref5.children;\n        var value = getPropsData(node).value;\n\n        if (!children || children.length === 0) {\n          targetValueList.push({\n            label: getLabel(values[value], valueEntities[value], treeNodeLabelProp),\n            value: value\n          });\n          return;\n        }\n\n        children.forEach(function (entity) {\n          traverse(entity);\n        });\n      };\n\n      hierarchyList.forEach(function (entity) {\n        traverse(entity);\n      });\n      return targetValueList;\n    }\n  }\n\n  return valueList.map(function (wrappedValue) {\n    return {\n      label: getLabel(wrappedValue, valueEntities[wrappedValue.value], treeNodeLabelProp),\n      value: wrappedValue.value\n    };\n  });\n}\n/**\n * Use `rc-tree` convertDataToTree to convert treeData to TreeNodes.\n * This will change the label to title value\n */\n\nfunction processProps(props) {\n  var title = props.title,\n      label = props.label,\n      key = props.key,\n      value = props.value;\n\n  var cloneProps = _extends({}, props); // Warning user not to use deprecated label prop.\n\n\n  if (label && !title) {\n    if (!warnDeprecatedLabel) {\n      warning(false, \"'label' in treeData is deprecated. Please use 'title' instead.\");\n      warnDeprecatedLabel = true;\n    }\n\n    cloneProps.title = label;\n  }\n\n  if (!key && (key === undefined || key === null)) {\n    cloneProps.key = value;\n  }\n\n  return cloneProps;\n}\n\nexport function convertDataToTree(treeData) {\n  return vcConvertDataToTree(treeData, {\n    processProps: processProps\n  });\n}\n/**\n * Use `rc-tree` convertTreeToEntities for entities calculation.\n * We have additional entities of `valueEntities`\n */\n\nfunction initWrapper(wrapper) {\n  return _extends(_extends({}, wrapper), {\n    valueEntities: {}\n  });\n}\n\nfunction processEntity(entity, wrapper) {\n  var value = getPropsData(entity.node).value;\n  entity.value = value; // This should be empty, or will get error message.\n\n  var currentEntity = wrapper.valueEntities[value];\n\n  if (currentEntity) {\n    warning(false, \"Conflict! value of node '\".concat(entity.key, \"' (\").concat(value, \") has already used by node '\").concat(currentEntity.key, \"'.\"));\n  }\n\n  wrapper.valueEntities[value] = entity;\n}\n\nexport function convertTreeToEntities(treeNodes) {\n  return vcConvertTreeToEntities(treeNodes, {\n    initWrapper: initWrapper,\n    processEntity: processEntity\n  });\n}\n/**\n * https://github.com/ant-design/ant-design/issues/13328\n * We need calculate the half check key when searchValue is set.\n */\n// TODO: This logic may better move to rc-tree\n\nexport function getHalfCheckedKeys(valueList, valueEntities) {\n  var values = {}; // Fill checked keys\n\n  valueList.forEach(function (_ref6) {\n    var value = _ref6.value;\n    values[value] = false;\n  }); // Fill half checked keys\n\n  valueList.forEach(function (_ref7) {\n    var value = _ref7.value;\n    var current = valueEntities[value];\n\n    while (current && current.parent) {\n      var parentValue = current.parent.value;\n      if (parentValue in values) break;\n      values[parentValue] = true;\n      current = current.parent;\n    }\n  }); // Get half keys\n\n  return Object.keys(values).filter(function (value) {\n    return values[value];\n  }).map(function (value) {\n    return valueEntities[value].key;\n  });\n}\nexport var conductCheck = rcConductCheck;"]},"metadata":{},"sourceType":"module"}