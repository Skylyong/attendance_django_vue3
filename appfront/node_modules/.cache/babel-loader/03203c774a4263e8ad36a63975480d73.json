{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { inBrowser } from \"@vant/use\";\nconst hasIntersectionObserver = inBrowser && \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype;\nconst modeType = {\n  event: \"event\",\n  observer: \"observer\"\n};\n\nfunction remove(arr, item) {\n  if (!arr.length) return;\n  const index = arr.indexOf(item);\n  if (index > -1) return arr.splice(index, 1);\n}\n\nfunction getBestSelectionFromSrcset(el, scale) {\n  if (el.tagName !== \"IMG\" || !el.getAttribute(\"data-srcset\")) return;\n  let options = el.getAttribute(\"data-srcset\");\n  const container = el.parentNode;\n  const containerWidth = container.offsetWidth * scale;\n  let spaceIndex;\n  let tmpSrc;\n  let tmpWidth;\n  options = options.trim().split(\",\");\n  const result = options.map(item => {\n    item = item.trim();\n    spaceIndex = item.lastIndexOf(\" \");\n\n    if (spaceIndex === -1) {\n      tmpSrc = item;\n      tmpWidth = 999998;\n    } else {\n      tmpSrc = item.substr(0, spaceIndex);\n      tmpWidth = parseInt(item.substr(spaceIndex + 1, item.length - spaceIndex - 2), 10);\n    }\n\n    return [tmpWidth, tmpSrc];\n  });\n  result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return 1;\n    }\n\n    if (a[0] > b[0]) {\n      return -1;\n    }\n\n    if (a[0] === b[0]) {\n      if (b[1].indexOf(\".webp\", b[1].length - 5) !== -1) {\n        return 1;\n      }\n\n      if (a[1].indexOf(\".webp\", a[1].length - 5) !== -1) {\n        return -1;\n      }\n    }\n\n    return 0;\n  });\n  let bestSelectedSrc = \"\";\n  let tmpOption;\n\n  for (let i = 0; i < result.length; i++) {\n    tmpOption = result[i];\n    bestSelectedSrc = tmpOption[1];\n    const next = result[i + 1];\n\n    if (next && next[0] < containerWidth) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    } else if (!next) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    }\n  }\n\n  return bestSelectedSrc;\n}\n\nconst getDPR = (scale = 1) => inBrowser ? window.devicePixelRatio || scale : scale;\n\nfunction supportWebp() {\n  if (!inBrowser) return false;\n  let support = true;\n\n  try {\n    const elem = document.createElement(\"canvas\");\n\n    if (elem.getContext && elem.getContext(\"2d\")) {\n      support = elem.toDataURL(\"image/webp\").indexOf(\"data:image/webp\") === 0;\n    }\n  } catch (err) {\n    support = false;\n  }\n\n  return support;\n}\n\nfunction throttle(action, delay) {\n  let timeout = null;\n  let lastRun = 0;\n  return function (...args) {\n    if (timeout) {\n      return;\n    }\n\n    const elapsed = Date.now() - lastRun;\n\n    const runCallback = () => {\n      lastRun = Date.now();\n      timeout = false;\n      action.apply(this, args);\n    };\n\n    if (elapsed >= delay) {\n      runCallback();\n    } else {\n      timeout = setTimeout(runCallback, delay);\n    }\n  };\n}\n\nfunction on(el, type, func) {\n  el.addEventListener(type, func, {\n    capture: false,\n    passive: true\n  });\n}\n\nfunction off(el, type, func) {\n  el.removeEventListener(type, func, false);\n}\n\nconst loadImageAsync = (item, resolve, reject) => {\n  const image = new Image();\n\n  if (!item || !item.src) {\n    return reject(new Error(\"image src is required\"));\n  }\n\n  image.src = item.src;\n\n  if (item.cors) {\n    image.crossOrigin = item.cors;\n  }\n\n  image.onload = () => resolve({\n    naturalHeight: image.naturalHeight,\n    naturalWidth: image.naturalWidth,\n    src: image.src\n  });\n\n  image.onerror = e => reject(e);\n};\n\nclass ImageCache {\n  constructor({\n    max\n  }) {\n    this.options = {\n      max: max || 100\n    };\n    this.caches = [];\n  }\n\n  has(key) {\n    return this.caches.indexOf(key) > -1;\n  }\n\n  add(key) {\n    if (this.has(key)) return;\n    this.caches.push(key);\n\n    if (this.caches.length > this.options.max) {\n      this.free();\n    }\n  }\n\n  free() {\n    this.caches.shift();\n  }\n\n}\n\nexport { ImageCache, getBestSelectionFromSrcset, getDPR, hasIntersectionObserver, loadImageAsync, modeType, off, on, remove, supportWebp, throttle };","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/node_modules/vant/es/lazyload/vue-lazyload/util.js"],"names":["inBrowser","hasIntersectionObserver","window","IntersectionObserverEntry","prototype","modeType","event","observer","remove","arr","item","length","index","indexOf","splice","getBestSelectionFromSrcset","el","scale","tagName","getAttribute","options","container","parentNode","containerWidth","offsetWidth","spaceIndex","tmpSrc","tmpWidth","trim","split","result","map","lastIndexOf","substr","parseInt","sort","a","b","bestSelectedSrc","tmpOption","i","next","getDPR","devicePixelRatio","supportWebp","support","elem","document","createElement","getContext","toDataURL","err","throttle","action","delay","timeout","lastRun","args","elapsed","Date","now","runCallback","apply","setTimeout","on","type","func","addEventListener","capture","passive","off","removeEventListener","loadImageAsync","resolve","reject","image","Image","src","Error","cors","crossOrigin","onload","naturalHeight","naturalWidth","onerror","e","ImageCache","constructor","max","caches","has","key","add","push","free","shift"],"mappings":"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","sourcesContent":["import { inBrowser } from \"@vant/use\";\nconst hasIntersectionObserver = inBrowser && \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype;\nconst modeType = {\n  event: \"event\",\n  observer: \"observer\"\n};\nfunction remove(arr, item) {\n  if (!arr.length)\n    return;\n  const index = arr.indexOf(item);\n  if (index > -1)\n    return arr.splice(index, 1);\n}\nfunction getBestSelectionFromSrcset(el, scale) {\n  if (el.tagName !== \"IMG\" || !el.getAttribute(\"data-srcset\"))\n    return;\n  let options = el.getAttribute(\"data-srcset\");\n  const container = el.parentNode;\n  const containerWidth = container.offsetWidth * scale;\n  let spaceIndex;\n  let tmpSrc;\n  let tmpWidth;\n  options = options.trim().split(\",\");\n  const result = options.map((item) => {\n    item = item.trim();\n    spaceIndex = item.lastIndexOf(\" \");\n    if (spaceIndex === -1) {\n      tmpSrc = item;\n      tmpWidth = 999998;\n    } else {\n      tmpSrc = item.substr(0, spaceIndex);\n      tmpWidth = parseInt(item.substr(spaceIndex + 1, item.length - spaceIndex - 2), 10);\n    }\n    return [tmpWidth, tmpSrc];\n  });\n  result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return 1;\n    }\n    if (a[0] > b[0]) {\n      return -1;\n    }\n    if (a[0] === b[0]) {\n      if (b[1].indexOf(\".webp\", b[1].length - 5) !== -1) {\n        return 1;\n      }\n      if (a[1].indexOf(\".webp\", a[1].length - 5) !== -1) {\n        return -1;\n      }\n    }\n    return 0;\n  });\n  let bestSelectedSrc = \"\";\n  let tmpOption;\n  for (let i = 0; i < result.length; i++) {\n    tmpOption = result[i];\n    bestSelectedSrc = tmpOption[1];\n    const next = result[i + 1];\n    if (next && next[0] < containerWidth) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    } else if (!next) {\n      bestSelectedSrc = tmpOption[1];\n      break;\n    }\n  }\n  return bestSelectedSrc;\n}\nconst getDPR = (scale = 1) => inBrowser ? window.devicePixelRatio || scale : scale;\nfunction supportWebp() {\n  if (!inBrowser)\n    return false;\n  let support = true;\n  try {\n    const elem = document.createElement(\"canvas\");\n    if (elem.getContext && elem.getContext(\"2d\")) {\n      support = elem.toDataURL(\"image/webp\").indexOf(\"data:image/webp\") === 0;\n    }\n  } catch (err) {\n    support = false;\n  }\n  return support;\n}\nfunction throttle(action, delay) {\n  let timeout = null;\n  let lastRun = 0;\n  return function(...args) {\n    if (timeout) {\n      return;\n    }\n    const elapsed = Date.now() - lastRun;\n    const runCallback = () => {\n      lastRun = Date.now();\n      timeout = false;\n      action.apply(this, args);\n    };\n    if (elapsed >= delay) {\n      runCallback();\n    } else {\n      timeout = setTimeout(runCallback, delay);\n    }\n  };\n}\nfunction on(el, type, func) {\n  el.addEventListener(type, func, {\n    capture: false,\n    passive: true\n  });\n}\nfunction off(el, type, func) {\n  el.removeEventListener(type, func, false);\n}\nconst loadImageAsync = (item, resolve, reject) => {\n  const image = new Image();\n  if (!item || !item.src) {\n    return reject(new Error(\"image src is required\"));\n  }\n  image.src = item.src;\n  if (item.cors) {\n    image.crossOrigin = item.cors;\n  }\n  image.onload = () => resolve({\n    naturalHeight: image.naturalHeight,\n    naturalWidth: image.naturalWidth,\n    src: image.src\n  });\n  image.onerror = (e) => reject(e);\n};\nclass ImageCache {\n  constructor({ max }) {\n    this.options = {\n      max: max || 100\n    };\n    this.caches = [];\n  }\n  has(key) {\n    return this.caches.indexOf(key) > -1;\n  }\n  add(key) {\n    if (this.has(key))\n      return;\n    this.caches.push(key);\n    if (this.caches.length > this.options.max) {\n      this.free();\n    }\n  }\n  free() {\n    this.caches.shift();\n  }\n}\nexport {\n  ImageCache,\n  getBestSelectionFromSrcset,\n  getDPR,\n  hasIntersectionObserver,\n  loadImageAsync,\n  modeType,\n  off,\n  on,\n  remove,\n  supportWebp,\n  throttle\n};\n"]},"metadata":{},"sourceType":"module"}