{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { initDefaultProps, hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: PropTypes.looseBool,\n  disabled: PropTypes.looseBool,\n  reverse: PropTypes.looseBool,\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: PropTypes.string,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  autofocus: PropTypes.looseBool\n};\nvar Range = {\n  name: 'Range',\n  inheritAttrs: false,\n  displayName: 'Range',\n  mixins: [BaseMixin],\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: []\n  }),\n  data: function data() {\n    var _this = this;\n\n    var count = this.count,\n        min = this.min,\n        max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n\n    if (value === undefined) {\n      value = defaultValue;\n    }\n\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n\n        this.__emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends(_extends({}, this.$data), state);\n\n      var changedValue = data.bounds;\n\n      this.__emit('change', changedValue);\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n\n      this.__emit('beforeChange', bounds);\n\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n\n      if (sHandle !== null || force) {\n        this.__emit('afterChange', this.bounds);\n      }\n\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var bounds = this.bounds,\n          sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n          reverse = _this$$props.reverse,\n          vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n            sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value > bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n          recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n          step = this.step,\n          min = this.min,\n          max = this.max;\n      var cache = this._getPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this._getPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var nextBounds = _toConsumableArray(this.bounds);\n\n      var sHandle = this.sHandle,\n          recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.__emit('afterChange', nextBounds);\n\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n          bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n          thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n          prefixCls = _ref3.prefixCls,\n          reverse = _ref3.reverse,\n          vertical = _ref3.vertical,\n          included = _ref3.included,\n          offsets = _ref3.offsets,\n          trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n\n      var sHandle = this.sHandle,\n          bounds = this.bounds,\n          prefixCls = this.prefixCls,\n          vertical = this.vertical,\n          included = this.included,\n          disabled = this.disabled,\n          min = this.min,\n          max = this.max,\n          reverse = this.reverse,\n          handle = this.handle,\n          defaultHandle = this.defaultHandle,\n          trackStyle = this.trackStyle,\n          handleStyle = this.handleStyle,\n          tabindex = this.tabindex;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n\n        var _tabIndex = tabindex[i] || 0;\n\n        if (disabled || tabindex[i] === null) {\n          _tabIndex = null;\n        }\n\n        return handleGenerator({\n          class: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: sHandle === i,\n          index: i,\n          tabindex: _tabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n};\nexport default createSlider(Range);","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"names":["_defineProperty","_extends","_toConsumableArray","createVNode","_createVNode","classNames","PropTypes","withUndefined","BaseMixin","initDefaultProps","hasProp","Track","createSlider","utils","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","looseBool","disabled","reverse","tabindex","prefixCls","string","min","max","autofocus","Range","name","inheritAttrs","displayName","mixins","data","_this","initialValue","Array","apply","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","__emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","onStart","position","calcValueByPos","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","onEnd","force","removeDocumentEvents","onMove","e","pauseEvent","oldValue","moveTo","onKeyboard","_this$$props","vertical","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","_getPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","slice","_","index","_classNames","trackClassName","concat","renderSlider","_this4","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","_classNames2","_tabIndex","class","offset","dragging","style","ref","h","saveHandle","onFocus","onBlur","tracks"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { initDefaultProps, hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: PropTypes.looseBool,\n  disabled: PropTypes.looseBool,\n  reverse: PropTypes.looseBool,\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: PropTypes.string,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  autofocus: PropTypes.looseBool\n};\nvar Range = {\n  name: 'Range',\n  inheritAttrs: false,\n  displayName: 'Range',\n  mixins: [BaseMixin],\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: []\n  }),\n  data: function data() {\n    var _this = this;\n\n    var count = this.count,\n        min = this.min,\n        max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n\n    if (value === undefined) {\n      value = defaultValue;\n    }\n\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n\n        this.__emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends(_extends({}, this.$data), state);\n\n      var changedValue = data.bounds;\n\n      this.__emit('change', changedValue);\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n\n      this.__emit('beforeChange', bounds);\n\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n\n      if (sHandle !== null || force) {\n        this.__emit('afterChange', this.bounds);\n      }\n\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var bounds = this.bounds,\n          sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n          reverse = _this$$props.reverse,\n          vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n            sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value > bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n          recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n          step = this.step,\n          min = this.min,\n          max = this.max;\n      var cache = this._getPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this._getPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var nextBounds = _toConsumableArray(this.bounds);\n\n      var sHandle = this.sHandle,\n          recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.__emit('afterChange', nextBounds);\n\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n          bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n          thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n          prefixCls = _ref3.prefixCls,\n          reverse = _ref3.reverse,\n          vertical = _ref3.vertical,\n          included = _ref3.included,\n          offsets = _ref3.offsets,\n          trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n\n      var sHandle = this.sHandle,\n          bounds = this.bounds,\n          prefixCls = this.prefixCls,\n          vertical = this.vertical,\n          included = this.included,\n          disabled = this.disabled,\n          min = this.min,\n          max = this.max,\n          reverse = this.reverse,\n          handle = this.handle,\n          defaultHandle = this.defaultHandle,\n          trackStyle = this.trackStyle,\n          handleStyle = this.handleStyle,\n          tabindex = this.tabindex;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n\n        var _tabIndex = tabindex[i] || 0;\n\n        if (disabled || tabindex[i] === null) {\n          _tabIndex = null;\n        }\n\n        return handleGenerator({\n          class: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: sHandle === i,\n          index: i,\n          tabindex: _tabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n};\nexport default createSlider(Range);"]},"metadata":{},"sourceType":"module"}