{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { nextTick } from 'vue';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport XEUtils from 'xe-utils';\nimport { getFuncText, eqEmptyValue } from '../../tools/utils';\nimport { scrollToView } from '../../tools/dom';\n/**\n * 校验规则\n */\n\nvar Rule =\n/** @class */\nfunction () {\n  function Rule(rule) {\n    Object.assign(this, {\n      $options: rule,\n      required: rule.required,\n      min: rule.min,\n      max: rule.max,\n      type: rule.type,\n      pattern: rule.pattern,\n      validator: rule.validator,\n      trigger: rule.trigger,\n      maxWidth: rule.maxWidth\n    });\n  }\n\n  Object.defineProperty(Rule.prototype, \"content\", {\n    /**\n     * 获取校验不通过的消息\n     * 支持国际化翻译\n     */\n    get: function () {\n      return getFuncText(this.$options.content || this.$options.message);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rule.prototype, \"message\", {\n    get: function () {\n      return this.content;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Rule;\n}();\n\nvar tableValidatorMethodKeys = ['fullValidate', 'validate', 'clearValidate'];\nvar validatorHook = {\n  setupTable: function ($xetable) {\n    var props = $xetable.props,\n        reactData = $xetable.reactData,\n        internalData = $xetable.internalData;\n    var refValidTooltip = $xetable.getRefMaps().refValidTooltip;\n\n    var _a = $xetable.getComputeMaps(),\n        computeValidOpts = _a.computeValidOpts,\n        computeTreeOpts = _a.computeTreeOpts,\n        computeEditOpts = _a.computeEditOpts;\n\n    var validatorMethods = {};\n    var validatorPrivateMethods = {};\n    var validRuleErr;\n    /**\n     * 聚焦到校验通过的单元格并弹出校验错误提示\n     */\n\n    var handleValidError = function (params) {\n      return new Promise(function (resolve) {\n        var validOpts = computeValidOpts.value;\n\n        if (validOpts.autoPos === false) {\n          $xetable.dispatchEvent('valid-error', params, null);\n          resolve();\n        } else {\n          $xetable.handleActived(params, {\n            type: 'valid-error',\n            trigger: 'call'\n          }).then(function () {\n            setTimeout(function () {\n              resolve(validatorPrivateMethods.showValidTooltip(params));\n            }, 10);\n          });\n        }\n      });\n    };\n    /**\n     * 对表格数据进行校验\n     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\n     * 如果传 true 则校验当前表格数据\n     * 如果传 row 指定行记录，则只验证传入的行\n     * 如果传 rows 为多行记录，则只验证传入的行\n     * 如果只传 callback 否则默认验证整个表格数据\n     * 返回 Promise 对象，或者使用回调方式\n     */\n\n\n    var beginValidate = function (rows, cb, isFull) {\n      var validRest = {};\n      var editRules = props.editRules,\n          treeConfig = props.treeConfig;\n      var afterFullData = internalData.afterFullData;\n      var treeOpts = computeTreeOpts.value;\n      var validOpts = computeValidOpts.value;\n      var vaildDatas;\n\n      if (rows === true) {\n        vaildDatas = afterFullData;\n      } else if (rows) {\n        if (XEUtils.isFunction(rows)) {\n          cb = rows;\n        } else {\n          vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n        }\n      }\n\n      if (!vaildDatas) {\n        if ($xetable.getInsertRecords) {\n          vaildDatas = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());\n        } else {\n          vaildDatas = [];\n        }\n      }\n\n      var rowValids = [];\n      internalData._lastCallTime = Date.now();\n      validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n\n      validatorMethods.clearValidate();\n\n      if (editRules) {\n        var columns_1 = $xetable.getColumns();\n\n        var handleVaild = function (row) {\n          if (isFull || !validRuleErr) {\n            var colVailds_1 = [];\n            columns_1.forEach(function (column) {\n              if ((isFull || !validRuleErr) && XEUtils.has(editRules, column.property)) {\n                colVailds_1.push(validatorPrivateMethods.validCellRules('all', row, column).catch(function (_a) {\n                  var rule = _a.rule,\n                      rules = _a.rules;\n                  var rest = {\n                    rule: rule,\n                    rules: rules,\n                    rowIndex: $xetable.getRowIndex(row),\n                    row: row,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    column: column,\n                    field: column.property,\n                    $table: $xetable\n                  };\n\n                  if (!validRest[column.property]) {\n                    validRest[column.property] = [];\n                  }\n\n                  validRest[column.property].push(rest);\n\n                  if (!isFull) {\n                    validRuleErr = true;\n                    return Promise.reject(rest);\n                  }\n                }));\n              }\n            });\n            rowValids.push(Promise.all(colVailds_1));\n          }\n        };\n\n        if (treeConfig) {\n          XEUtils.eachTree(vaildDatas, handleVaild, treeOpts);\n        } else {\n          vaildDatas.forEach(handleVaild);\n        }\n\n        return Promise.all(rowValids).then(function () {\n          var ruleProps = Object.keys(validRest);\n          return nextTick().then(function () {\n            if (ruleProps.length) {\n              return Promise.reject(validRest[ruleProps[0]][0]);\n            }\n\n            if (cb) {\n              cb();\n            }\n          });\n        }).catch(function (firstErrParams) {\n          return new Promise(function (resolve, reject) {\n            var finish = function () {\n              nextTick(function () {\n                if (cb) {\n                  cb(validRest);\n                  resolve();\n                } else {\n                  if (GlobalConfig.validToReject === 'obsolete') {\n                    // 已废弃，校验失败将不会执行catch\n                    reject(validRest);\n                  } else {\n                    resolve(validRest);\n                  }\n                }\n              });\n            };\n\n            var posAndFinish = function () {\n              firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);\n              scrollToView(firstErrParams.cell);\n              handleValidError(firstErrParams).then(finish);\n            };\n            /**\n             * 当校验不通过时\n             * 将表格滚动到可视区\n             * 由于提示信息至少需要占一行，定位向上偏移一行\n             */\n\n\n            var row = firstErrParams.row;\n            var rowIndex = afterFullData.indexOf(row);\n            var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n\n            if (validOpts.autoPos === false) {\n              finish();\n            } else {\n              if (treeConfig) {\n                $xetable.scrollToTreeRow(locatRow).then(posAndFinish);\n              } else {\n                $xetable.scrollToRow(locatRow).then(posAndFinish);\n              }\n            }\n          });\n        });\n      }\n\n      return nextTick().then(function () {\n        if (cb) {\n          cb();\n        }\n      });\n    };\n\n    validatorMethods = {\n      /**\n       * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\n       */\n      fullValidate: function (rows, cb) {\n        return beginValidate(rows, cb, true);\n      },\n\n      /**\n       * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\n       */\n      validate: function (rows, cb) {\n        return beginValidate(rows, cb);\n      },\n      clearValidate: function () {\n        var validStore = reactData.validStore;\n        var validTip = refValidTooltip.value;\n        Object.assign(validStore, {\n          visible: false,\n          row: null,\n          column: null,\n          content: '',\n          rule: null\n        });\n\n        if (validTip && validTip.reactData.visible) {\n          validTip.close();\n        }\n\n        return nextTick();\n      }\n    };\n\n    var validErrorRuleValue = function (rule, val) {\n      var type = rule.type,\n          min = rule.min,\n          max = rule.max,\n          pattern = rule.pattern;\n      var isNumType = type === 'number';\n      var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val); // 判断数值\n\n      if (isNumType && isNaN(val)) {\n        return true;\n      } // 如果存在 min，判断最小值\n\n\n      if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n        return true;\n      } // 如果存在 max，判断最大值\n\n\n      if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n        return true;\n      } // 如果存在 pattern，正则校验\n\n\n      if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n        return true;\n      }\n\n      return false;\n    };\n\n    validatorPrivateMethods = {\n      /**\n       * 校验数据\n       * 按表格行、列顺序依次校验（同步或异步）\n       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\n       * 如果是传回调方式这返回一个校验不通过列的错误消息\n       *\n       * rule 配置：\n       *  required=Boolean 是否必填\n       *  min=Number 最小长度\n       *  max=Number 最大长度\n       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\n       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\n       */\n      validCellRules: function (validType, row, column, val) {\n        var editRules = props.editRules;\n        var property = column.property;\n        var errorRules = [];\n        var syncVailds = [];\n\n        if (property && editRules) {\n          var rules_1 = XEUtils.get(editRules, property);\n\n          if (rules_1) {\n            var cellValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(row, property) : val;\n            rules_1.forEach(function (rule) {\n              var type = rule.type,\n                  trigger = rule.trigger,\n                  required = rule.required;\n\n              if (validType === 'all' || !trigger || validType === trigger) {\n                if (XEUtils.isFunction(rule.validator)) {\n                  var customValid = rule.validator({\n                    cellValue: cellValue_1,\n                    rule: rule,\n                    rules: rules_1,\n                    row: row,\n                    rowIndex: $xetable.getRowIndex(row),\n                    column: column,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    field: column.property,\n                    $table: $xetable\n                  });\n\n                  if (customValid) {\n                    if (XEUtils.isError(customValid)) {\n                      validRuleErr = true;\n                      errorRules.push(new Rule({\n                        type: 'custom',\n                        trigger: trigger,\n                        content: customValid.message,\n                        rule: new Rule(rule)\n                      }));\n                    } else if (customValid.catch) {\n                      // 如果为异步校验（注：异步校验是并发无序的）\n                      syncVailds.push(customValid.catch(function (e) {\n                        validRuleErr = true;\n                        errorRules.push(new Rule({\n                          type: 'custom',\n                          trigger: trigger,\n                          content: e && e.message ? e.message : rule.content || rule.message,\n                          rule: new Rule(rule)\n                        }));\n                      }));\n                    }\n                  }\n                } else {\n                  var isArrType = type === 'array';\n                  var hasEmpty = isArrType ? !XEUtils.isArray(cellValue_1) || !cellValue_1.length : eqEmptyValue(cellValue_1);\n\n                  if (required ? hasEmpty || validErrorRuleValue(rule, cellValue_1) : !hasEmpty && validErrorRuleValue(rule, cellValue_1)) {\n                    validRuleErr = true;\n                    errorRules.push(new Rule(rule));\n                  }\n                }\n              }\n            });\n          }\n        }\n\n        return Promise.all(syncVailds).then(function () {\n          if (errorRules.length) {\n            var rest = {\n              rules: errorRules,\n              rule: errorRules[0]\n            };\n            return Promise.reject(rest);\n          }\n        });\n      },\n      hasCellRules: function (type, row, column) {\n        var editRules = props.editRules;\n        var property = column.property;\n\n        if (property && editRules) {\n          var rules = XEUtils.get(editRules, property);\n          return rules && !!XEUtils.find(rules, function (rule) {\n            return type === 'all' || !rule.trigger || type === rule.trigger;\n          });\n        }\n\n        return false;\n      },\n\n      /**\n       * 触发校验\n       */\n      triggerValidate: function (type) {\n        var editConfig = props.editConfig,\n            editRules = props.editRules;\n        var editStore = reactData.editStore,\n            validStore = reactData.validStore;\n        var actived = editStore.actived;\n        var editOpts = computeEditOpts.value;\n\n        if (editConfig && editRules && actived.row) {\n          var _a = actived.args,\n              row_1 = _a.row,\n              column_1 = _a.column,\n              cell_1 = _a.cell;\n\n          if (validatorPrivateMethods.hasCellRules(type, row_1, column_1)) {\n            return validatorPrivateMethods.validCellRules(type, row_1, column_1).then(function () {\n              if (editOpts.mode === 'row') {\n                if (validStore.visible && validStore.row === row_1 && validStore.column === column_1) {\n                  validatorMethods.clearValidate();\n                }\n              }\n            }).catch(function (_a) {\n              var rule = _a.rule; // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n\n              if (!rule.trigger || type === rule.trigger) {\n                var rest = {\n                  rule: rule,\n                  row: row_1,\n                  column: column_1,\n                  cell: cell_1\n                };\n                validatorPrivateMethods.showValidTooltip(rest);\n                return Promise.reject(rest);\n              }\n\n              return Promise.resolve();\n            });\n          }\n        }\n\n        return Promise.resolve();\n      },\n\n      /**\n       * 弹出校验错误提示\n       */\n      showValidTooltip: function (params) {\n        var height = props.height;\n        var tableData = reactData.tableData,\n            validStore = reactData.validStore;\n        var validOpts = computeValidOpts.value;\n        var rule = params.rule,\n            row = params.row,\n            column = params.column,\n            cell = params.cell;\n        var validTip = refValidTooltip.value;\n        var content = rule.content;\n        return nextTick().then(function () {\n          Object.assign(validStore, {\n            row: row,\n            column: column,\n            rule: rule,\n            content: content,\n            visible: true\n          });\n          $xetable.dispatchEvent('valid-error', params, null);\n\n          if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {\n            return validTip.open(cell, content);\n          }\n        });\n      }\n    };\n    return __assign(__assign({}, validatorMethods), validatorPrivateMethods);\n  },\n  setupGrid: function ($xegrid) {\n    return $xegrid.extendTableMethods(tableValidatorMethodKeys);\n  }\n};\nexport default validatorHook;","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/node_modules/vxe-table/es/validator/src/hook.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","nextTick","GlobalConfig","XEUtils","getFuncText","eqEmptyValue","scrollToView","Rule","rule","$options","required","min","max","type","pattern","validator","trigger","maxWidth","defineProperty","get","content","message","enumerable","configurable","tableValidatorMethodKeys","validatorHook","setupTable","$xetable","props","reactData","internalData","refValidTooltip","getRefMaps","_a","getComputeMaps","computeValidOpts","computeTreeOpts","computeEditOpts","validatorMethods","validatorPrivateMethods","validRuleErr","handleValidError","params","Promise","resolve","validOpts","value","autoPos","dispatchEvent","handleActived","then","setTimeout","showValidTooltip","beginValidate","rows","cb","isFull","validRest","editRules","treeConfig","afterFullData","treeOpts","vaildDatas","isFunction","isArray","getInsertRecords","concat","getUpdateRecords","rowValids","_lastCallTime","Date","now","clearValidate","columns_1","getColumns","handleVaild","row","colVailds_1","forEach","column","has","property","push","validCellRules","catch","rules","rest","rowIndex","getRowIndex","columnIndex","getColumnIndex","field","$table","reject","all","eachTree","ruleProps","keys","firstErrParams","finish","validToReject","posAndFinish","cell","getCell","indexOf","locatRow","scrollToTreeRow","scrollToRow","fullValidate","validate","validStore","validTip","visible","close","validErrorRuleValue","val","isNumType","numVal","toNumber","getSize","isNaN","eqNull","isRegExp","RegExp","test","validType","errorRules","syncVailds","rules_1","cellValue_1","isUndefined","customValid","cellValue","isError","e","isArrType","hasEmpty","hasCellRules","find","triggerValidate","editConfig","editStore","actived","editOpts","args","row_1","column_1","cell_1","mode","height","tableData","open","setupGrid","$xegrid","extendTableMethods"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { nextTick } from 'vue';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport XEUtils from 'xe-utils';\nimport { getFuncText, eqEmptyValue } from '../../tools/utils';\nimport { scrollToView } from '../../tools/dom';\n/**\n * 校验规则\n */\nvar Rule = /** @class */ (function () {\n    function Rule(rule) {\n        Object.assign(this, {\n            $options: rule,\n            required: rule.required,\n            min: rule.min,\n            max: rule.max,\n            type: rule.type,\n            pattern: rule.pattern,\n            validator: rule.validator,\n            trigger: rule.trigger,\n            maxWidth: rule.maxWidth\n        });\n    }\n    Object.defineProperty(Rule.prototype, \"content\", {\n        /**\n         * 获取校验不通过的消息\n         * 支持国际化翻译\n         */\n        get: function () {\n            return getFuncText(this.$options.content || this.$options.message);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rule.prototype, \"message\", {\n        get: function () {\n            return this.content;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Rule;\n}());\nvar tableValidatorMethodKeys = ['fullValidate', 'validate', 'clearValidate'];\nvar validatorHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var refValidTooltip = $xetable.getRefMaps().refValidTooltip;\n        var _a = $xetable.getComputeMaps(), computeValidOpts = _a.computeValidOpts, computeTreeOpts = _a.computeTreeOpts, computeEditOpts = _a.computeEditOpts;\n        var validatorMethods = {};\n        var validatorPrivateMethods = {};\n        var validRuleErr;\n        /**\n         * 聚焦到校验通过的单元格并弹出校验错误提示\n         */\n        var handleValidError = function (params) {\n            return new Promise(function (resolve) {\n                var validOpts = computeValidOpts.value;\n                if (validOpts.autoPos === false) {\n                    $xetable.dispatchEvent('valid-error', params, null);\n                    resolve();\n                }\n                else {\n                    $xetable.handleActived(params, { type: 'valid-error', trigger: 'call' }).then(function () {\n                        setTimeout(function () {\n                            resolve(validatorPrivateMethods.showValidTooltip(params));\n                        }, 10);\n                    });\n                }\n            });\n        };\n        /**\n         * 对表格数据进行校验\n         * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\n         * 如果传 true 则校验当前表格数据\n         * 如果传 row 指定行记录，则只验证传入的行\n         * 如果传 rows 为多行记录，则只验证传入的行\n         * 如果只传 callback 否则默认验证整个表格数据\n         * 返回 Promise 对象，或者使用回调方式\n         */\n        var beginValidate = function (rows, cb, isFull) {\n            var validRest = {};\n            var editRules = props.editRules, treeConfig = props.treeConfig;\n            var afterFullData = internalData.afterFullData;\n            var treeOpts = computeTreeOpts.value;\n            var validOpts = computeValidOpts.value;\n            var vaildDatas;\n            if (rows === true) {\n                vaildDatas = afterFullData;\n            }\n            else if (rows) {\n                if (XEUtils.isFunction(rows)) {\n                    cb = rows;\n                }\n                else {\n                    vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n                }\n            }\n            if (!vaildDatas) {\n                if ($xetable.getInsertRecords) {\n                    vaildDatas = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());\n                }\n                else {\n                    vaildDatas = [];\n                }\n            }\n            var rowValids = [];\n            internalData._lastCallTime = Date.now();\n            validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n            validatorMethods.clearValidate();\n            if (editRules) {\n                var columns_1 = $xetable.getColumns();\n                var handleVaild = function (row) {\n                    if (isFull || !validRuleErr) {\n                        var colVailds_1 = [];\n                        columns_1.forEach(function (column) {\n                            if ((isFull || !validRuleErr) && XEUtils.has(editRules, column.property)) {\n                                colVailds_1.push(validatorPrivateMethods.validCellRules('all', row, column)\n                                    .catch(function (_a) {\n                                    var rule = _a.rule, rules = _a.rules;\n                                    var rest = {\n                                        rule: rule,\n                                        rules: rules,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        row: row,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        column: column,\n                                        field: column.property,\n                                        $table: $xetable\n                                    };\n                                    if (!validRest[column.property]) {\n                                        validRest[column.property] = [];\n                                    }\n                                    validRest[column.property].push(rest);\n                                    if (!isFull) {\n                                        validRuleErr = true;\n                                        return Promise.reject(rest);\n                                    }\n                                }));\n                            }\n                        });\n                        rowValids.push(Promise.all(colVailds_1));\n                    }\n                };\n                if (treeConfig) {\n                    XEUtils.eachTree(vaildDatas, handleVaild, treeOpts);\n                }\n                else {\n                    vaildDatas.forEach(handleVaild);\n                }\n                return Promise.all(rowValids).then(function () {\n                    var ruleProps = Object.keys(validRest);\n                    return nextTick().then(function () {\n                        if (ruleProps.length) {\n                            return Promise.reject(validRest[ruleProps[0]][0]);\n                        }\n                        if (cb) {\n                            cb();\n                        }\n                    });\n                }).catch(function (firstErrParams) {\n                    return new Promise(function (resolve, reject) {\n                        var finish = function () {\n                            nextTick(function () {\n                                if (cb) {\n                                    cb(validRest);\n                                    resolve();\n                                }\n                                else {\n                                    if (GlobalConfig.validToReject === 'obsolete') {\n                                        // 已废弃，校验失败将不会执行catch\n                                        reject(validRest);\n                                    }\n                                    else {\n                                        resolve(validRest);\n                                    }\n                                }\n                            });\n                        };\n                        var posAndFinish = function () {\n                            firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);\n                            scrollToView(firstErrParams.cell);\n                            handleValidError(firstErrParams).then(finish);\n                        };\n                        /**\n                         * 当校验不通过时\n                         * 将表格滚动到可视区\n                         * 由于提示信息至少需要占一行，定位向上偏移一行\n                         */\n                        var row = firstErrParams.row;\n                        var rowIndex = afterFullData.indexOf(row);\n                        var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n                        if (validOpts.autoPos === false) {\n                            finish();\n                        }\n                        else {\n                            if (treeConfig) {\n                                $xetable.scrollToTreeRow(locatRow).then(posAndFinish);\n                            }\n                            else {\n                                $xetable.scrollToRow(locatRow).then(posAndFinish);\n                            }\n                        }\n                    });\n                });\n            }\n            return nextTick().then(function () {\n                if (cb) {\n                    cb();\n                }\n            });\n        };\n        validatorMethods = {\n            /**\n             * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\n             */\n            fullValidate: function (rows, cb) {\n                return beginValidate(rows, cb, true);\n            },\n            /**\n             * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\n             */\n            validate: function (rows, cb) {\n                return beginValidate(rows, cb);\n            },\n            clearValidate: function () {\n                var validStore = reactData.validStore;\n                var validTip = refValidTooltip.value;\n                Object.assign(validStore, {\n                    visible: false,\n                    row: null,\n                    column: null,\n                    content: '',\n                    rule: null\n                });\n                if (validTip && validTip.reactData.visible) {\n                    validTip.close();\n                }\n                return nextTick();\n            }\n        };\n        var validErrorRuleValue = function (rule, val) {\n            var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n            var isNumType = type === 'number';\n            var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n            // 判断数值\n            if (isNumType && isNaN(val)) {\n                return true;\n            }\n            // 如果存在 min，判断最小值\n            if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n                return true;\n            }\n            // 如果存在 max，判断最大值\n            if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n                return true;\n            }\n            // 如果存在 pattern，正则校验\n            if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n                return true;\n            }\n            return false;\n        };\n        validatorPrivateMethods = {\n            /**\n             * 校验数据\n             * 按表格行、列顺序依次校验（同步或异步）\n             * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n             * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\n             * 如果是传回调方式这返回一个校验不通过列的错误消息\n             *\n             * rule 配置：\n             *  required=Boolean 是否必填\n             *  min=Number 最小长度\n             *  max=Number 最大长度\n             *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\n             *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\n             */\n            validCellRules: function (validType, row, column, val) {\n                var editRules = props.editRules;\n                var property = column.property;\n                var errorRules = [];\n                var syncVailds = [];\n                if (property && editRules) {\n                    var rules_1 = XEUtils.get(editRules, property);\n                    if (rules_1) {\n                        var cellValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(row, property) : val;\n                        rules_1.forEach(function (rule) {\n                            var type = rule.type, trigger = rule.trigger, required = rule.required;\n                            if (validType === 'all' || !trigger || validType === trigger) {\n                                if (XEUtils.isFunction(rule.validator)) {\n                                    var customValid = rule.validator({\n                                        cellValue: cellValue_1,\n                                        rule: rule,\n                                        rules: rules_1,\n                                        row: row,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        column: column,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        field: column.property,\n                                        $table: $xetable\n                                    });\n                                    if (customValid) {\n                                        if (XEUtils.isError(customValid)) {\n                                            validRuleErr = true;\n                                            errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: customValid.message, rule: new Rule(rule) }));\n                                        }\n                                        else if (customValid.catch) {\n                                            // 如果为异步校验（注：异步校验是并发无序的）\n                                            syncVailds.push(customValid.catch(function (e) {\n                                                validRuleErr = true;\n                                                errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: e && e.message ? e.message : (rule.content || rule.message), rule: new Rule(rule) }));\n                                            }));\n                                        }\n                                    }\n                                }\n                                else {\n                                    var isArrType = type === 'array';\n                                    var hasEmpty = isArrType ? (!XEUtils.isArray(cellValue_1) || !cellValue_1.length) : eqEmptyValue(cellValue_1);\n                                    if (required ? (hasEmpty || validErrorRuleValue(rule, cellValue_1)) : (!hasEmpty && validErrorRuleValue(rule, cellValue_1))) {\n                                        validRuleErr = true;\n                                        errorRules.push(new Rule(rule));\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n                return Promise.all(syncVailds).then(function () {\n                    if (errorRules.length) {\n                        var rest = { rules: errorRules, rule: errorRules[0] };\n                        return Promise.reject(rest);\n                    }\n                });\n            },\n            hasCellRules: function (type, row, column) {\n                var editRules = props.editRules;\n                var property = column.property;\n                if (property && editRules) {\n                    var rules = XEUtils.get(editRules, property);\n                    return rules && !!XEUtils.find(rules, function (rule) { return type === 'all' || !rule.trigger || type === rule.trigger; });\n                }\n                return false;\n            },\n            /**\n             * 触发校验\n             */\n            triggerValidate: function (type) {\n                var editConfig = props.editConfig, editRules = props.editRules;\n                var editStore = reactData.editStore, validStore = reactData.validStore;\n                var actived = editStore.actived;\n                var editOpts = computeEditOpts.value;\n                if (editConfig && editRules && actived.row) {\n                    var _a = actived.args, row_1 = _a.row, column_1 = _a.column, cell_1 = _a.cell;\n                    if (validatorPrivateMethods.hasCellRules(type, row_1, column_1)) {\n                        return validatorPrivateMethods.validCellRules(type, row_1, column_1).then(function () {\n                            if (editOpts.mode === 'row') {\n                                if (validStore.visible && validStore.row === row_1 && validStore.column === column_1) {\n                                    validatorMethods.clearValidate();\n                                }\n                            }\n                        }).catch(function (_a) {\n                            var rule = _a.rule;\n                            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n                            if (!rule.trigger || type === rule.trigger) {\n                                var rest = { rule: rule, row: row_1, column: column_1, cell: cell_1 };\n                                validatorPrivateMethods.showValidTooltip(rest);\n                                return Promise.reject(rest);\n                            }\n                            return Promise.resolve();\n                        });\n                    }\n                }\n                return Promise.resolve();\n            },\n            /**\n             * 弹出校验错误提示\n             */\n            showValidTooltip: function (params) {\n                var height = props.height;\n                var tableData = reactData.tableData, validStore = reactData.validStore;\n                var validOpts = computeValidOpts.value;\n                var rule = params.rule, row = params.row, column = params.column, cell = params.cell;\n                var validTip = refValidTooltip.value;\n                var content = rule.content;\n                return nextTick().then(function () {\n                    Object.assign(validStore, {\n                        row: row,\n                        column: column,\n                        rule: rule,\n                        content: content,\n                        visible: true\n                    });\n                    $xetable.dispatchEvent('valid-error', params, null);\n                    if (validTip && (validOpts.message === 'tooltip' || (validOpts.message === 'default' && !height && tableData.length < 2))) {\n                        return validTip.open(cell, content);\n                    }\n                });\n            }\n        };\n        return __assign(__assign({}, validatorMethods), validatorPrivateMethods);\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableValidatorMethodKeys);\n    }\n};\nexport default validatorHook;\n"]},"metadata":{},"sourceType":"module"}