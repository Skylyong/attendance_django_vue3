{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport var getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n  var onDemandSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n\n  return onDemandSlides;\n}; // return list of slides that need to be present\n\nexport var getRequiredLazySlides = function getRequiredLazySlides(spec) {\n  var requiredSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n\n  return requiredSlides;\n}; // startIndex that needs to be present\n\nexport var lazyStartIndex = function lazyStartIndex(spec) {\n  return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nexport var lazyEndIndex = function lazyEndIndex(spec) {\n  return spec.currentSlide + lazySlidesOnRight(spec);\n};\nexport var lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nexport var lazySlidesOnRight = function lazySlidesOnRight(spec) {\n  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n}; // get width of an element\n\nexport var getWidth = function getWidth(elem) {\n  return elem && elem.offsetWidth || 0;\n};\nexport var getHeight = function getHeight(elem) {\n  return elem && elem.offsetHeight || 0;\n};\nexport var getSwipeDirection = function getSwipeDirection(touchObject) {\n  var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var swipeAngle;\n  var xDist = touchObject.startX - touchObject.curX;\n  var yDist = touchObject.startY - touchObject.curY;\n  var r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return 'left';\n  }\n\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return 'right';\n  }\n\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return 'up';\n    } else {\n      return 'down';\n    }\n  }\n\n  return 'vertical';\n}; // whether or not we can go next\n\nexport var canGoNext = function canGoNext(spec) {\n  var canGo = true;\n\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n\n  return canGo;\n}; // given an object and a list of keys, return new object with given keys\n\nexport var extractObject = function extractObject(spec, keys) {\n  var newObject = {};\n  keys.forEach(function (key) {\n    return newObject[key] = spec[key];\n  });\n  return newObject;\n}; // get initialized state\n\nexport var initializedState = function initializedState(spec) {\n  // spec also contains listRef, trackRef\n  var slideCount = spec.children.length;\n  var listWidth = Math.ceil(getWidth(spec.listRef));\n  var trackWidth = Math.ceil(getWidth(spec.trackRef));\n  var slideWidth;\n\n  if (!spec.vertical) {\n    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n\n    if (typeof spec.centerPadding === 'string' && spec.centerPadding.slice(-1) === '%') {\n      centerPaddingAdj *= listWidth / 100;\n    }\n\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n\n  var slideHeight = spec.listRef && getHeight(spec.listRef.querySelector('[data-index=\"0\"]'));\n  var listHeight = slideHeight * spec.slidesToShow;\n  var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n\n  var lazyLoadedList = spec.lazyLoadedList || [];\n  var slidesToLoad = getOnDemandLazySlides({\n    currentSlide: currentSlide,\n    lazyLoadedList: lazyLoadedList\n  }, spec);\n  lazyLoadedList.concat(slidesToLoad);\n  var state = {\n    slideCount: slideCount,\n    slideWidth: slideWidth,\n    listWidth: listWidth,\n    trackWidth: trackWidth,\n    currentSlide: currentSlide,\n    slideHeight: slideHeight,\n    listHeight: listHeight,\n    lazyLoadedList: lazyLoadedList\n  };\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state['autoplaying'] = 'playing';\n  }\n\n  return state;\n};\nexport var slideHandler = function slideHandler(spec) {\n  var waitForAnimate = spec.waitForAnimate,\n      animating = spec.animating,\n      fade = spec.fade,\n      infinite = spec.infinite,\n      index = spec.index,\n      slideCount = spec.slideCount,\n      lazyLoadedList = spec.lazyLoadedList,\n      lazyLoad = spec.lazyLoad,\n      currentSlide = spec.currentSlide,\n      centerMode = spec.centerMode,\n      slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      useCSS = spec.useCSS;\n  if (waitForAnimate && animating) return {};\n  var animationSlide = index;\n  var finalSlide;\n  var animationLeft;\n  var finalLeft;\n  var state = {};\n  var nextState = {};\n\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide);\n    }\n\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList: lazyLoadedList\n    };\n    nextState = {\n      animating: false\n    };\n  } else {\n    finalSlide = animationSlide;\n\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) {\n        finalSlide = slideCount - slideCount % slidesToScroll;\n      }\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n\n    animationLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: finalSlide\n    }));\n\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n\n    lazyLoad && lazyLoadedList.concat(getOnDemandLazySlides(_extends(_extends({}, spec), {\n      currentSlide: animationSlide\n    })));\n\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        lazyLoadedList: lazyLoadedList\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_extends(_extends({}, spec), {\n          left: animationLeft\n        })),\n        lazyLoadedList: lazyLoadedList\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        swipeLeft: null\n      };\n    }\n  }\n\n  return {\n    state: state,\n    nextState: nextState\n  };\n};\nexport var changeSlide = function changeSlide(spec, options) {\n  var previousInt, slideOffset, targetSlide;\n  var slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      slideCount = spec.slideCount,\n      currentSlide = spec.currentSlide,\n      lazyLoad = spec.lazyLoad,\n      infinite = spec.infinite;\n  var unevenOffset = slideCount % slidesToScroll !== 0;\n  var indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n\n  if (options.message === 'previous') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n  } else if (options.message === 'next') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n  } else if (options.message === 'dots') {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  } else if (options.message === 'children') {\n    // Click on the slides\n    targetSlide = options.index;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n\n    if (infinite) {\n      var direction = siblingDirection(_extends(_extends({}, spec), {\n        targetSlide: targetSlide\n      }));\n\n      if (targetSlide > options.currentSlide && direction === 'left') {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === 'right') {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === 'index') {\n    targetSlide = Number(options.index);\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  }\n\n  return targetSlide;\n};\nexport var keyHandler = function keyHandler(e, accessibility, rtl) {\n  if (e.target.tagName.match('TEXTAREA|INPUT|SELECT') || !accessibility) {\n    return '';\n  }\n\n  if (e.keyCode === 37) return rtl ? 'next' : 'previous';\n  if (e.keyCode === 39) return rtl ? 'previous' : 'next';\n  return '';\n};\nexport var swipeStart = function swipeStart(e, swipe, draggable) {\n  e.target.tagName === 'IMG' && e.preventDefault();\n  if (!swipe || !draggable && e.type.indexOf('mouse') !== -1) return '';\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport var swipeMove = function swipeMove(e, spec) {\n  // spec also contains, trackRef and slideIndex\n  var scrolling = spec.scrolling,\n      animating = spec.animating,\n      vertical = spec.vertical,\n      swipeToSlide = spec.swipeToSlide,\n      verticalSwiping = spec.verticalSwiping,\n      rtl = spec.rtl,\n      currentSlide = spec.currentSlide,\n      edgeFriction = spec.edgeFriction,\n      edgeDragged = spec.edgeDragged,\n      onEdge = spec.onEdge,\n      swiped = spec.swiped,\n      swiping = spec.swiping,\n      slideCount = spec.slideCount,\n      slidesToScroll = spec.slidesToScroll,\n      infinite = spec.infinite,\n      touchObject = spec.touchObject,\n      swipeEvent = spec.swipeEvent,\n      listHeight = spec.listHeight,\n      listWidth = spec.listWidth;\n  if (scrolling) return;\n  if (animating) return e.preventDefault();\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();\n  var swipeLeft;\n  var state = {};\n  var curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n\n  if (verticalSwiping) {\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  }\n\n  var dotCount = Math.ceil(slideCount / slidesToScroll);\n  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  var touchSwipeLength = touchObject.swipeLength;\n\n  if (!infinite) {\n    if (currentSlide === 0 && swipeDirection === 'right' || currentSlide + 1 >= dotCount && swipeDirection === 'left' || !canGoNext(spec) && swipeDirection === 'left') {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state['edgeDragged'] = true;\n      }\n    }\n  }\n\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state['swiped'] = true;\n  }\n\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n\n  state = _extends(_extends({}, state), {\n    touchObject: touchObject,\n    swipeLeft: swipeLeft,\n    trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n      left: swipeLeft\n    }))\n  });\n\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > 10) {\n    state['swiping'] = true;\n    e.preventDefault();\n  }\n\n  return state;\n};\nexport var swipeEnd = function swipeEnd(e, spec) {\n  var dragging = spec.dragging,\n      swipe = spec.swipe,\n      touchObject = spec.touchObject,\n      listWidth = spec.listWidth,\n      touchThreshold = spec.touchThreshold,\n      verticalSwiping = spec.verticalSwiping,\n      listHeight = spec.listHeight,\n      currentSlide = spec.currentSlide,\n      swipeToSlide = spec.swipeToSlide,\n      scrolling = spec.scrolling,\n      onSwipe = spec.onSwipe;\n\n  if (!dragging) {\n    if (swipe) e.preventDefault();\n    return {};\n  }\n\n  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n\n  var state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n\n  if (scrolling) {\n    return state;\n  }\n\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault();\n\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n\n    var slideCount, newSlide;\n\n    switch (swipeDirection) {\n      case 'left':\n      case 'up':\n        newSlide = currentSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 0;\n        break;\n\n      case 'right':\n      case 'down':\n        newSlide = currentSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 1;\n        break;\n\n      default:\n        slideCount = currentSlide;\n    }\n\n    state['triggerSlideHandler'] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    var currentLeft = getTrackLeft(spec);\n    state['trackStyle'] = getTrackAnimateCSS(_extends(_extends({}, spec), {\n      left: currentLeft\n    }));\n  }\n\n  return state;\n};\nexport var getNavigableIndexes = function getNavigableIndexes(spec) {\n  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var indexes = [];\n\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n\n  return indexes;\n};\nexport var checkNavigable = function checkNavigable(spec, index) {\n  var navigables = getNavigableIndexes(spec);\n  var prevNavigable = 0;\n\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (var n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n\n      prevNavigable = navigables[n];\n    }\n  }\n\n  return index;\n};\nexport var getSlideCount = function getSlideCount(spec) {\n  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n\n  if (spec.swipeToSlide) {\n    var swipedSlide;\n    var slickList = spec.listRef;\n    var slides = slickList.querySelectorAll('.slick-slide');\n    Array.from(slides).every(function (slide) {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!swipedSlide) {\n      return 0;\n    }\n\n    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport var checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n  return keysArray.reduce(function (value, key) {\n    return value && spec.hasOwnProperty(key);\n  }, true) ? null : console.error('Keys Missing:', spec);\n};\nexport var getTrackCSS = function getTrackCSS(spec) {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth']);\n  var trackWidth, trackHeight;\n  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n\n  var style = {\n    opacity: 1,\n    transition: '',\n    WebkitTransition: ''\n  };\n\n  if (spec.useTransform) {\n    var WebkitTransform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    var transform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    var msTransform = !spec.vertical ? 'translateX(' + spec.left + 'px)' : 'translateY(' + spec.left + 'px)';\n    style = _extends(_extends({}, style), {\n      WebkitTransform: WebkitTransform,\n      transform: transform,\n      msTransform: msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style['top'] = spec.left;\n    } else {\n      style['left'] = spec.left;\n    }\n  }\n\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth + 'px';\n  if (trackHeight) style.height = trackHeight + 'px'; // Fallback for IE8\n\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + 'px';\n    } else {\n      style.marginTop = spec.left + 'px';\n    }\n  }\n\n  return style;\n};\nexport var getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth', 'speed', 'cssEase']);\n  var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n\n  if (spec.useTransform) {\n    style.WebkitTransition = '-webkit-transform ' + spec.speed + 'ms ' + spec.cssEase;\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase;\n    } else {\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase;\n    }\n  }\n\n  return style;\n};\nexport var getTrackLeft = function getTrackLeft(spec) {\n  if (spec.unslick) {\n    return 0;\n  }\n\n  checkSpecKeys(spec, ['slideIndex', 'trackRef', 'infinite', 'centerMode', 'slideCount', 'slidesToShow', 'slidesToScroll', 'slideWidth', 'listWidth', 'variableWidth', 'slideHeight']);\n  var slideIndex = spec.slideIndex,\n      trackRef = spec.trackRef,\n      infinite = spec.infinite,\n      centerMode = spec.centerMode,\n      slideCount = spec.slideCount,\n      slidesToShow = spec.slidesToShow,\n      slidesToScroll = spec.slidesToScroll,\n      slideWidth = spec.slideWidth,\n      listWidth = spec.listWidth,\n      variableWidth = spec.variableWidth,\n      slideHeight = spec.slideHeight,\n      fade = spec.fade,\n      vertical = spec.vertical;\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n\n  var slidesToOffset = 0;\n\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    } // shift current slide to center of the frame\n\n\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    var trackElem = trackRef;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n\n      for (var slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n\n  return targetLeft;\n};\nexport var getPreClones = function getPreClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport var getPostClones = function getPostClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  return spec.slideCount;\n};\nexport var getTotalSlides = function getTotalSlides(spec) {\n  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nexport var siblingDirection = function siblingDirection(spec) {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return 'left';\n    }\n\n    return 'right';\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return 'right';\n    }\n\n    return 'left';\n  }\n};\nexport var slidesOnRight = function slidesOnRight(_ref) {\n  var slidesToShow = _ref.slidesToShow,\n      centerMode = _ref.centerMode,\n      rtl = _ref.rtl,\n      centerPadding = _ref.centerPadding; // returns no of slides on the right of active slide\n\n  if (centerMode) {\n    var right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n\n  if (rtl) {\n    return 0;\n  }\n\n  return slidesToShow - 1;\n};\nexport var slidesOnLeft = function slidesOnLeft(_ref2) {\n  var slidesToShow = _ref2.slidesToShow,\n      centerMode = _ref2.centerMode,\n      rtl = _ref2.rtl,\n      centerPadding = _ref2.centerPadding; // returns no of slides on the left of active slide\n\n  if (centerMode) {\n    var left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n\n  return 0;\n};\nexport var canUseDOM = function canUseDOM() {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n};","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/node_modules/ant-design-vue/es/vc-slick/src/utils/innerSliderUtils.js"],"names":["_extends","getOnDemandLazySlides","spec","onDemandSlides","startIndex","lazyStartIndex","endIndex","lazyEndIndex","slideIndex","lazyLoadedList","indexOf","push","getRequiredLazySlides","requiredSlides","currentSlide","lazySlidesOnLeft","lazySlidesOnRight","centerMode","Math","floor","slidesToShow","parseInt","centerPadding","getWidth","elem","offsetWidth","getHeight","offsetHeight","getSwipeDirection","touchObject","verticalSwiping","arguments","length","undefined","swipeAngle","xDist","startX","curX","yDist","startY","curY","r","atan2","round","PI","abs","canGoNext","canGo","infinite","slideCount","extractObject","keys","newObject","forEach","key","initializedState","children","listWidth","ceil","listRef","trackWidth","trackRef","slideWidth","vertical","centerPaddingAdj","slice","slideHeight","querySelector","listHeight","initialSlide","rtl","slidesToLoad","concat","state","autoplaying","autoplay","slideHandler","waitForAnimate","animating","fade","index","lazyLoad","slidesToScroll","useCSS","animationSlide","finalSlide","animationLeft","finalLeft","nextState","getTrackLeft","trackStyle","getTrackCSS","left","getTrackAnimateCSS","swipeLeft","changeSlide","options","previousInt","slideOffset","targetSlide","unevenOffset","indexOffset","message","direction","siblingDirection","Number","keyHandler","e","accessibility","target","tagName","match","keyCode","swipeStart","swipe","draggable","preventDefault","type","dragging","touches","pageX","clientX","pageY","clientY","swipeMove","scrolling","swipeToSlide","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","curLeft","swipeLength","sqrt","pow","verticalSwipeLength","positionOffset","dotCount","swipeDirection","touchSwipeLength","swipeEnd","touchThreshold","onSwipe","minSwipe","newSlide","getSlideCount","checkNavigable","currentLeft","getNavigableIndexes","max","breakpoint","counter","indexes","min","navigables","prevNavigable","n","centerOffset","swipedSlide","slickList","slides","querySelectorAll","Array","from","every","slide","offsetLeft","offsetTop","currentIndex","slidesTraversed","dataset","checkSpecKeys","keysArray","reduce","value","hasOwnProperty","console","error","trackHeight","trackChildren","getTotalSlides","style","opacity","transition","WebkitTransition","useTransform","WebkitTransform","transform","msTransform","width","height","window","addEventListener","attachEvent","marginLeft","marginTop","speed","cssEase","unslick","variableWidth","targetLeft","verticalOffset","slidesToOffset","getPreClones","targetSlideIndex","trackElem","childNodes","getPostClones","slidesOnRight","slidesOnLeft","_ref","right","_ref2","canUseDOM","document","createElement"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport var getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n  var onDemandSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n\n  return onDemandSlides;\n}; // return list of slides that need to be present\n\nexport var getRequiredLazySlides = function getRequiredLazySlides(spec) {\n  var requiredSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n\n  return requiredSlides;\n}; // startIndex that needs to be present\n\nexport var lazyStartIndex = function lazyStartIndex(spec) {\n  return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nexport var lazyEndIndex = function lazyEndIndex(spec) {\n  return spec.currentSlide + lazySlidesOnRight(spec);\n};\nexport var lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nexport var lazySlidesOnRight = function lazySlidesOnRight(spec) {\n  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n}; // get width of an element\n\nexport var getWidth = function getWidth(elem) {\n  return elem && elem.offsetWidth || 0;\n};\nexport var getHeight = function getHeight(elem) {\n  return elem && elem.offsetHeight || 0;\n};\nexport var getSwipeDirection = function getSwipeDirection(touchObject) {\n  var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var swipeAngle;\n  var xDist = touchObject.startX - touchObject.curX;\n  var yDist = touchObject.startY - touchObject.curY;\n  var r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return 'left';\n  }\n\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return 'right';\n  }\n\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return 'up';\n    } else {\n      return 'down';\n    }\n  }\n\n  return 'vertical';\n}; // whether or not we can go next\n\nexport var canGoNext = function canGoNext(spec) {\n  var canGo = true;\n\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n\n  return canGo;\n}; // given an object and a list of keys, return new object with given keys\n\nexport var extractObject = function extractObject(spec, keys) {\n  var newObject = {};\n  keys.forEach(function (key) {\n    return newObject[key] = spec[key];\n  });\n  return newObject;\n}; // get initialized state\n\nexport var initializedState = function initializedState(spec) {\n  // spec also contains listRef, trackRef\n  var slideCount = spec.children.length;\n  var listWidth = Math.ceil(getWidth(spec.listRef));\n  var trackWidth = Math.ceil(getWidth(spec.trackRef));\n  var slideWidth;\n\n  if (!spec.vertical) {\n    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n\n    if (typeof spec.centerPadding === 'string' && spec.centerPadding.slice(-1) === '%') {\n      centerPaddingAdj *= listWidth / 100;\n    }\n\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n\n  var slideHeight = spec.listRef && getHeight(spec.listRef.querySelector('[data-index=\"0\"]'));\n  var listHeight = slideHeight * spec.slidesToShow;\n  var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n\n  var lazyLoadedList = spec.lazyLoadedList || [];\n  var slidesToLoad = getOnDemandLazySlides({\n    currentSlide: currentSlide,\n    lazyLoadedList: lazyLoadedList\n  }, spec);\n  lazyLoadedList.concat(slidesToLoad);\n  var state = {\n    slideCount: slideCount,\n    slideWidth: slideWidth,\n    listWidth: listWidth,\n    trackWidth: trackWidth,\n    currentSlide: currentSlide,\n    slideHeight: slideHeight,\n    listHeight: listHeight,\n    lazyLoadedList: lazyLoadedList\n  };\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state['autoplaying'] = 'playing';\n  }\n\n  return state;\n};\nexport var slideHandler = function slideHandler(spec) {\n  var waitForAnimate = spec.waitForAnimate,\n      animating = spec.animating,\n      fade = spec.fade,\n      infinite = spec.infinite,\n      index = spec.index,\n      slideCount = spec.slideCount,\n      lazyLoadedList = spec.lazyLoadedList,\n      lazyLoad = spec.lazyLoad,\n      currentSlide = spec.currentSlide,\n      centerMode = spec.centerMode,\n      slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      useCSS = spec.useCSS;\n  if (waitForAnimate && animating) return {};\n  var animationSlide = index;\n  var finalSlide;\n  var animationLeft;\n  var finalLeft;\n  var state = {};\n  var nextState = {};\n\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide);\n    }\n\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList: lazyLoadedList\n    };\n    nextState = {\n      animating: false\n    };\n  } else {\n    finalSlide = animationSlide;\n\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) {\n        finalSlide = slideCount - slideCount % slidesToScroll;\n      }\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n\n    animationLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: finalSlide\n    }));\n\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n\n    lazyLoad && lazyLoadedList.concat(getOnDemandLazySlides(_extends(_extends({}, spec), {\n      currentSlide: animationSlide\n    })));\n\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        lazyLoadedList: lazyLoadedList\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_extends(_extends({}, spec), {\n          left: animationLeft\n        })),\n        lazyLoadedList: lazyLoadedList\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        swipeLeft: null\n      };\n    }\n  }\n\n  return {\n    state: state,\n    nextState: nextState\n  };\n};\nexport var changeSlide = function changeSlide(spec, options) {\n  var previousInt, slideOffset, targetSlide;\n  var slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      slideCount = spec.slideCount,\n      currentSlide = spec.currentSlide,\n      lazyLoad = spec.lazyLoad,\n      infinite = spec.infinite;\n  var unevenOffset = slideCount % slidesToScroll !== 0;\n  var indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n\n  if (options.message === 'previous') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n  } else if (options.message === 'next') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n  } else if (options.message === 'dots') {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  } else if (options.message === 'children') {\n    // Click on the slides\n    targetSlide = options.index;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n\n    if (infinite) {\n      var direction = siblingDirection(_extends(_extends({}, spec), {\n        targetSlide: targetSlide\n      }));\n\n      if (targetSlide > options.currentSlide && direction === 'left') {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === 'right') {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === 'index') {\n    targetSlide = Number(options.index);\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  }\n\n  return targetSlide;\n};\nexport var keyHandler = function keyHandler(e, accessibility, rtl) {\n  if (e.target.tagName.match('TEXTAREA|INPUT|SELECT') || !accessibility) {\n    return '';\n  }\n\n  if (e.keyCode === 37) return rtl ? 'next' : 'previous';\n  if (e.keyCode === 39) return rtl ? 'previous' : 'next';\n  return '';\n};\nexport var swipeStart = function swipeStart(e, swipe, draggable) {\n  e.target.tagName === 'IMG' && e.preventDefault();\n  if (!swipe || !draggable && e.type.indexOf('mouse') !== -1) return '';\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport var swipeMove = function swipeMove(e, spec) {\n  // spec also contains, trackRef and slideIndex\n  var scrolling = spec.scrolling,\n      animating = spec.animating,\n      vertical = spec.vertical,\n      swipeToSlide = spec.swipeToSlide,\n      verticalSwiping = spec.verticalSwiping,\n      rtl = spec.rtl,\n      currentSlide = spec.currentSlide,\n      edgeFriction = spec.edgeFriction,\n      edgeDragged = spec.edgeDragged,\n      onEdge = spec.onEdge,\n      swiped = spec.swiped,\n      swiping = spec.swiping,\n      slideCount = spec.slideCount,\n      slidesToScroll = spec.slidesToScroll,\n      infinite = spec.infinite,\n      touchObject = spec.touchObject,\n      swipeEvent = spec.swipeEvent,\n      listHeight = spec.listHeight,\n      listWidth = spec.listWidth;\n  if (scrolling) return;\n  if (animating) return e.preventDefault();\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();\n  var swipeLeft;\n  var state = {};\n  var curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n\n  if (verticalSwiping) {\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  }\n\n  var dotCount = Math.ceil(slideCount / slidesToScroll);\n  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  var touchSwipeLength = touchObject.swipeLength;\n\n  if (!infinite) {\n    if (currentSlide === 0 && swipeDirection === 'right' || currentSlide + 1 >= dotCount && swipeDirection === 'left' || !canGoNext(spec) && swipeDirection === 'left') {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state['edgeDragged'] = true;\n      }\n    }\n  }\n\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state['swiped'] = true;\n  }\n\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n\n  state = _extends(_extends({}, state), {\n    touchObject: touchObject,\n    swipeLeft: swipeLeft,\n    trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n      left: swipeLeft\n    }))\n  });\n\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > 10) {\n    state['swiping'] = true;\n    e.preventDefault();\n  }\n\n  return state;\n};\nexport var swipeEnd = function swipeEnd(e, spec) {\n  var dragging = spec.dragging,\n      swipe = spec.swipe,\n      touchObject = spec.touchObject,\n      listWidth = spec.listWidth,\n      touchThreshold = spec.touchThreshold,\n      verticalSwiping = spec.verticalSwiping,\n      listHeight = spec.listHeight,\n      currentSlide = spec.currentSlide,\n      swipeToSlide = spec.swipeToSlide,\n      scrolling = spec.scrolling,\n      onSwipe = spec.onSwipe;\n\n  if (!dragging) {\n    if (swipe) e.preventDefault();\n    return {};\n  }\n\n  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n\n  var state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n\n  if (scrolling) {\n    return state;\n  }\n\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault();\n\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n\n    var slideCount, newSlide;\n\n    switch (swipeDirection) {\n      case 'left':\n      case 'up':\n        newSlide = currentSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 0;\n        break;\n\n      case 'right':\n      case 'down':\n        newSlide = currentSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 1;\n        break;\n\n      default:\n        slideCount = currentSlide;\n    }\n\n    state['triggerSlideHandler'] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    var currentLeft = getTrackLeft(spec);\n    state['trackStyle'] = getTrackAnimateCSS(_extends(_extends({}, spec), {\n      left: currentLeft\n    }));\n  }\n\n  return state;\n};\nexport var getNavigableIndexes = function getNavigableIndexes(spec) {\n  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var indexes = [];\n\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n\n  return indexes;\n};\nexport var checkNavigable = function checkNavigable(spec, index) {\n  var navigables = getNavigableIndexes(spec);\n  var prevNavigable = 0;\n\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (var n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n\n      prevNavigable = navigables[n];\n    }\n  }\n\n  return index;\n};\nexport var getSlideCount = function getSlideCount(spec) {\n  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n\n  if (spec.swipeToSlide) {\n    var swipedSlide;\n    var slickList = spec.listRef;\n    var slides = slickList.querySelectorAll('.slick-slide');\n    Array.from(slides).every(function (slide) {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!swipedSlide) {\n      return 0;\n    }\n\n    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport var checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n  return keysArray.reduce(function (value, key) {\n    return value && spec.hasOwnProperty(key);\n  }, true) ? null : console.error('Keys Missing:', spec);\n};\nexport var getTrackCSS = function getTrackCSS(spec) {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth']);\n  var trackWidth, trackHeight;\n  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n\n  var style = {\n    opacity: 1,\n    transition: '',\n    WebkitTransition: ''\n  };\n\n  if (spec.useTransform) {\n    var WebkitTransform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    var transform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    var msTransform = !spec.vertical ? 'translateX(' + spec.left + 'px)' : 'translateY(' + spec.left + 'px)';\n    style = _extends(_extends({}, style), {\n      WebkitTransform: WebkitTransform,\n      transform: transform,\n      msTransform: msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style['top'] = spec.left;\n    } else {\n      style['left'] = spec.left;\n    }\n  }\n\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth + 'px';\n  if (trackHeight) style.height = trackHeight + 'px'; // Fallback for IE8\n\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + 'px';\n    } else {\n      style.marginTop = spec.left + 'px';\n    }\n  }\n\n  return style;\n};\nexport var getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth', 'speed', 'cssEase']);\n  var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n\n  if (spec.useTransform) {\n    style.WebkitTransition = '-webkit-transform ' + spec.speed + 'ms ' + spec.cssEase;\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase;\n    } else {\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase;\n    }\n  }\n\n  return style;\n};\nexport var getTrackLeft = function getTrackLeft(spec) {\n  if (spec.unslick) {\n    return 0;\n  }\n\n  checkSpecKeys(spec, ['slideIndex', 'trackRef', 'infinite', 'centerMode', 'slideCount', 'slidesToShow', 'slidesToScroll', 'slideWidth', 'listWidth', 'variableWidth', 'slideHeight']);\n  var slideIndex = spec.slideIndex,\n      trackRef = spec.trackRef,\n      infinite = spec.infinite,\n      centerMode = spec.centerMode,\n      slideCount = spec.slideCount,\n      slidesToShow = spec.slidesToShow,\n      slidesToScroll = spec.slidesToScroll,\n      slideWidth = spec.slideWidth,\n      listWidth = spec.listWidth,\n      variableWidth = spec.variableWidth,\n      slideHeight = spec.slideHeight,\n      fade = spec.fade,\n      vertical = spec.vertical;\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n\n  var slidesToOffset = 0;\n\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    } // shift current slide to center of the frame\n\n\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    var trackElem = trackRef;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n\n      for (var slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n\n  return targetLeft;\n};\nexport var getPreClones = function getPreClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport var getPostClones = function getPostClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  return spec.slideCount;\n};\nexport var getTotalSlides = function getTotalSlides(spec) {\n  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nexport var siblingDirection = function siblingDirection(spec) {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return 'left';\n    }\n\n    return 'right';\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return 'right';\n    }\n\n    return 'left';\n  }\n};\nexport var slidesOnRight = function slidesOnRight(_ref) {\n  var slidesToShow = _ref.slidesToShow,\n      centerMode = _ref.centerMode,\n      rtl = _ref.rtl,\n      centerPadding = _ref.centerPadding;\n\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    var right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n\n  if (rtl) {\n    return 0;\n  }\n\n  return slidesToShow - 1;\n};\nexport var slidesOnLeft = function slidesOnLeft(_ref2) {\n  var slidesToShow = _ref2.slidesToShow,\n      centerMode = _ref2.centerMode,\n      rtl = _ref2.rtl,\n      centerPadding = _ref2.centerPadding;\n\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    var left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n\n  return 0;\n};\nexport var canUseDOM = function canUseDOM() {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n};"]},"metadata":{},"sourceType":"module"}