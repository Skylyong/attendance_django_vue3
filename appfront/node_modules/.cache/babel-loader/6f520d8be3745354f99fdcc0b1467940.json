{"ast":null,"code":"import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport { remove, on, off, throttle, supportWebp, getDPR, getBestSelectionFromSrcset, hasIntersectionObserver, modeType, ImageCache } from \"./util\";\nimport { isObject } from \"../../utils\";\nimport ReactiveListener from \"./listener\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\"scroll\", \"wheel\", \"mousewheel\", \"resize\", \"animationend\", \"transitionend\", \"touchmove\"];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\n\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({\n        max: 200\n      });\n      this.lazyLoadHandler = throttle(this.lazyLoadHandler.bind(this), this.options.throttleWait);\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n\n    performance() {\n      return this.listeners.map(item => item.performance());\n    }\n\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n\n    add(el, binding, vnode) {\n      if (this.listeners.some(item => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n\n      const value = this.valueFormatter(binding.value);\n      let {\n        src\n      } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let {\n        src\n      } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find(item => item.el === el);\n\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n\n    remove(el) {\n      if (!el) return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find(item => item.el === el);\n\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n\n    removeComponent(vm) {\n      if (!vm) return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n\n      this.removeListenerTarget(window);\n    }\n\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n\n      this.mode = mode;\n\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach(listener => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n\n        this.targets.forEach(target => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach(target => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n\n    addListenerTarget(el) {\n      if (!el) return;\n      let target = this.targets.find(target2 => target2.el === el);\n\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n\n      return this.targetIndex;\n    }\n\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(evt => (start ? on : off)(el, evt, this.lazyLoadHandler));\n    }\n\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event]) this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n\n        this.$on(event, on2);\n      };\n\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event]) return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n\n        remove(this.Event.listeners[event], func);\n      };\n\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event]) return;\n        this.Event.listeners[event].forEach(func => func(context, inCache));\n      };\n    }\n\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach(listener => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n\n        const catIn = listener.checkInView();\n        if (!catIn) return;\n        listener.load();\n      });\n      freeList.forEach(item => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n\n      this.observer = new IntersectionObserver(this.observerHandler.bind(this), this.options.observerOptions);\n\n      if (this.listeners.length) {\n        this.listeners.forEach(listener => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n\n    observerHandler(entries) {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach(listener => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded) return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n\n    elRenderer(listener, state, cache) {\n      if (!listener.el) return;\n      const {\n        el,\n        bindType\n      } = listener;\n      let src;\n\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n\n        case \"error\":\n          src = listener.error;\n          break;\n\n        default:\n          ({\n            src\n          } = listener);\n          break;\n      }\n\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n\n    valueFormatter(value) {\n      let src = value;\n      let {\n        loading,\n        error\n      } = this.options;\n\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n\n        ({\n          src\n        } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n\n  };\n}\n\nexport { stdin_default as default };","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/node_modules/vant/es/lazyload/vue-lazyload/lazy.js"],"names":["nextTick","inBrowser","getScrollParent","remove","on","off","throttle","supportWebp","getDPR","getBestSelectionFromSrcset","hasIntersectionObserver","modeType","ImageCache","isObject","ReactiveListener","DEFAULT_URL","DEFAULT_EVENTS","DEFAULT_OBSERVER_OPTIONS","rootMargin","threshold","stdin_default","Lazy","constructor","preLoad","error","throttleWait","preLoadTop","dispatchEvent","loading","attempt","silent","scale","listenEvents","filter","adapter","observer","observerOptions","mode","event","listeners","targetIndex","targets","options","ListenEvents","initEvent","imageCache","max","lazyLoadHandler","bind","setMode","config","Object","assign","performance","map","item","addLazyBox","vm","push","addListenerTarget","window","observe","el","$el","parentNode","add","binding","vnode","some","update","value","valueFormatter","src","container","keys","modifiers","$parent","context","$refs","document","getElementById","newListener","bindType","arg","cors","elRenderer","exist","find","unobserve","existItem","removeListenerTarget","$destroy","removeComponent","forEach","listener","target","initListen","initIntersectionObserver","target2","id","childrenCount","listened","index","splice","start","evt","Event","loaded","$on","func","$once","on2","args","$off","apply","length","$emit","inCache","freeList","catIn","checkInView","load","IntersectionObserver","observerHandler","entries","entry","isIntersecting","state","cache","style","getAttribute","setAttribute","CustomEvent","detail","process","env","NODE_ENV","console","default"],"mappings":"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","sourcesContent":["import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util\";\nimport { isObject } from \"../../utils\";\nimport ReactiveListener from \"./listener\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(this.lazyLoadHandler.bind(this), this.options.throttleWait);\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    remove(el) {\n      if (!el)\n        return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    removeComponent(vm) {\n      if (!vm)\n        return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(window);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    addListenerTarget(el) {\n      if (!el)\n        return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    initListen(el, start) {\n      this.options.ListenEvents.forEach((evt) => (start ? on : off)(el, evt, this.lazyLoadHandler));\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event])\n          this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event])\n            return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event])\n          return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn)\n          return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(this.observerHandler.bind(this), this.options.observerOptions);\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    elRenderer(listener, state, cache) {\n      if (!listener.el)\n        return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n"]},"metadata":{},"sourceType":"module"}