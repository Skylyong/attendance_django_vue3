{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport raf from '../../_util/raf';\nexport default function useScrollTo(containerRef, mergedData, heights, props, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scroll = null;\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    } // Normal scroll logic\n\n\n    raf.cancel(scroll);\n    var data = mergedData.value;\n    var itemHeight = props.itemHeight;\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n\n      var _arg$offset = arg.offset,\n          offset = _arg$offset === void 0 ? 0 : _arg$offset; // We will retry 3 times in case dynamic height shaking\n\n      var syncScroll = function syncScroll(times, targetAlign) {\n        if (times < 0 || !containerRef.value) return;\n        var height = containerRef.value.clientHeight;\n        var needCollectHeight = false;\n        var newTargetAlign = targetAlign; // Go to next frame if height not exist\n\n        if (height) {\n          var mergedAlign = targetAlign || align; // Get top & bottom\n\n          var stackTop = 0;\n          var itemTop = 0;\n          var itemBottom = 0;\n          var maxLen = Math.min(data.length, index);\n\n          for (var i = 0; i <= maxLen; i += 1) {\n            var key = getKey(data[i]);\n            itemTop = stackTop;\n            var cacheHeight = heights[key];\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          } // Scroll to\n\n\n          var targetTop = null;\n\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop - offset;\n              break;\n\n            case 'bottom':\n              targetTop = itemBottom - height + offset;\n              break;\n\n            default:\n              {\n                var scrollTop = containerRef.value.scrollTop;\n                var scrollBottom = scrollTop + height;\n\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n\n          if (targetTop !== null && targetTop !== containerRef.value.scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        } // We will retry since element may not sync height as it described\n\n\n        scroll = raf(function () {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n\n          syncScroll(times - 1, newTargetAlign);\n        });\n      };\n\n      syncScroll(3);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/node_modules/ant-design-vue/es/vc-virtual-list/hooks/useScrollTo.js"],"names":["_typeof","raf","useScrollTo","containerRef","mergedData","heights","props","getKey","collectHeight","syncScrollTop","triggerFlash","scroll","arg","undefined","cancel","data","value","itemHeight","index","align","findIndex","item","key","_arg$offset","offset","syncScroll","times","targetAlign","height","clientHeight","needCollectHeight","newTargetAlign","mergedAlign","stackTop","itemTop","itemBottom","maxLen","Math","min","length","i","cacheHeight","targetTop","scrollTop","scrollBottom"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport raf from '../../_util/raf';\nexport default function useScrollTo(containerRef, mergedData, heights, props, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scroll = null;\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    } // Normal scroll logic\n\n\n    raf.cancel(scroll);\n    var data = mergedData.value;\n    var itemHeight = props.itemHeight;\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n\n      var _arg$offset = arg.offset,\n          offset = _arg$offset === void 0 ? 0 : _arg$offset; // We will retry 3 times in case dynamic height shaking\n\n      var syncScroll = function syncScroll(times, targetAlign) {\n        if (times < 0 || !containerRef.value) return;\n        var height = containerRef.value.clientHeight;\n        var needCollectHeight = false;\n        var newTargetAlign = targetAlign; // Go to next frame if height not exist\n\n        if (height) {\n          var mergedAlign = targetAlign || align; // Get top & bottom\n\n          var stackTop = 0;\n          var itemTop = 0;\n          var itemBottom = 0;\n          var maxLen = Math.min(data.length, index);\n\n          for (var i = 0; i <= maxLen; i += 1) {\n            var key = getKey(data[i]);\n            itemTop = stackTop;\n            var cacheHeight = heights[key];\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          } // Scroll to\n\n\n          var targetTop = null;\n\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop - offset;\n              break;\n\n            case 'bottom':\n              targetTop = itemBottom - height + offset;\n              break;\n\n            default:\n              {\n                var scrollTop = containerRef.value.scrollTop;\n                var scrollBottom = scrollTop + height;\n\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n\n          if (targetTop !== null && targetTop !== containerRef.value.scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        } // We will retry since element may not sync height as it described\n\n\n        scroll = raf(function () {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n\n          syncScroll(times - 1, newTargetAlign);\n        });\n      };\n\n      syncScroll(3);\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}