{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport PropTypes from '../_util/vue-types';\nimport classNames from '../_util/classNames';\nimport omit from 'omit.js';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nvar affixProps = {\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: PropTypes.number,\n  offset: PropTypes.number,\n\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: PropTypes.number,\n\n  /** 固定状态改变时触发的回调函数 */\n  // onChange?: (affixed?: boolean) => void;\n\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: PropTypes.func.def(getDefaultTarget),\n  prefixCls: PropTypes.string,\n  onChange: PropTypes.func,\n  onTestUpdatePosition: PropTypes.func\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps,\n  emits: ['change', 'testUpdatePosition'],\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = null;\n\n      if (val) {\n        newTarget = val() || null;\n      }\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"sources":["/Users/lyong/Desktop/myproj/appfront/node_modules/ant-design-vue/es/affix/index.js"],"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","PropTypes","classNames","omit","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","number","offset","offsetBottom","target","func","def","prefixCls","string","onChange","onTestUpdatePosition","Affix","name","props","emits","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_a","className","restProps","default","_default","call"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport PropTypes from '../_util/vue-types';\nimport classNames from '../_util/classNames';\nimport omit from 'omit.js';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nvar affixProps = {\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: PropTypes.number,\n  offset: PropTypes.number,\n\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: PropTypes.number,\n\n  /** 固定状态改变时触发的回调函数 */\n  // onChange?: (affixed?: boolean) => void;\n\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: PropTypes.func.def(getDefaultTarget),\n  prefixCls: PropTypes.string,\n  onChange: PropTypes.func,\n  onTestUpdatePosition: PropTypes.func\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps,\n  emits: ['change', 'testUpdatePosition'],\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = null;\n\n      if (val) {\n        newTarget = val() || null;\n      }\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"]},"metadata":{},"sourceType":"module"}